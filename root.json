{
  "fs": {
    "/etc/shadow": {
      "perm": "root:root:600",
      "content": "root:secret:0:0:99999:7:::\nwolfgang:waff:0:0:99999:7:::\nguest:password:0:0:99999:7:::\n",
      "hash": "948f4f3bb4f40b6129f45391cf1efe0a180bfdefb23df267c42516289887f46f"
    },
    "/etc/group": {
      "perm": "root:root:600",
      "content": "root:x:0:\nsudo:x:1:wolfgang\nwolfgang:x:2:\nguest:x:3:\n",
      "hash": "1089453544b5c3fbdd6ae85cbefd7cfb00ff3795f49dfe09e7fd07621a43aea1"
    },
    "/etc/passwd": {
      "perm": "root:root:600",
      "content": "root:x:0:0:root:/root:/bin/shell\nwolfgang:x:1:2:,,,:/home/wolfgang:/bin/shell\nguest:x:2:3:,,,:/home/guest:/bin/shell\n",
      "hash": "6b03700127d04349b4f25a367fa4bf15a71ab07e945c60bcf4e985fd8a09177a"
    },
    "/usr/bin/test": {
      "perm": "root:root:755",
      "content": "#!/bin/shell\n\nfunc section name;\n    echo \"\\n==============================\";\n    echo \"\\t$name\";\n    echo \"==============================\";\nendfunc;\n\nfunc say msg;\n    echo $msg;\nendfunc;\n\nsection \"Tokens\";\n\necho $PATH;\n\necho ${pwd};\n\necho \"${ls -e ${pwd}}\";\n\necho \"123${pwd}xyz\";\n\necho \"abc{$path}abc{$user}abc\";\n\nsection \"loop.sh\";\nif \"~/loop.sh\" is file;\n    cat \"~/loop.sh\";\nendif;\n\nsay \"test funcs\";\n\nsection \"files\";\n\nmkdir -s ttt;\n\ncd ttt;\n\ntouch -s a;\ntouch -s b;\n\nsection vars;\n\nset ls \"${ls -c /bin}\";\n\nprintvar;\n\nsection arrays;\n\necho ${count $ls};\n\nwhile ${count ls} > 0;\n    echo ${pop ls};\nendwhile;\n",
      "hash": "c7746ff6ac3623852713d3d370a2ae9481abc5d37104033dd802c341083e54e8"
    },
    "/usr/bin/test-rm": {
      "perm": "root:root:755",
      "content": "#!/bin/shell\n\nmkdir test-rm;\nmkdir test-rm/b;\nmkdir test-rm/c;\n\ntouch test-rm/a;\n\nmkdir test-rm/c/1;\nmkdir test-rm/c/2;\ntouch test-rm/c/x;\n\nrm -rf test-rm;\n",
      "hash": "29d086a1c4020a5f96cac0c98f082ec0d68d561bafce4e200f2f40c4184983e9"
    },
    "/usr/bin/test-loop": {
      "perm": "root:root:755",
      "content": "#!/bin/shell\n\nset loop 0;\n\n:start;\n\nsum loop 1;\n\necho round $loop;\n\nsleep 0.1;\n\nif $loop < 10;\n\ngoto start;\n\nelse;\n\necho \"Done!!!\";\n\nendif;\n",
      "hash": "a794ec63a5b0b28ac55777989be077dd95b408d611fce02c1dbb0eb5a99b6a4c"
    },
    "/usr/bin/fizzbuzz": {
      "perm": "root:root:755",
      "content": "#!/bin/shell\n\nfunc fizzbuzz num;\n\n    set out $num;\n\n    if not $num % 3;\n        set out \"$out fizz\";\n    endif;\n\n    if not $num % 5;\n        set out \"$out buzz\";\n    endif;\n\n    echo $out;\n\nendfunc;\n\nset count 1;\n\nwhile $count <= 100;\n\n    fizzbuzz $count;\n\n    sum count 1;\n\nendwhile;\n",
      "hash": "a1e4541bcb9a910a86d14dbb87036080883cff473d7b7af9366325a9aeaea2f6"
    },
    "/usr/bin/test-nested": {
      "perm": "root:root:755",
      "content": "#!/bin/shell\n\nfunc test1 arga;\n\n    echo $arga;\n\n    test2 $arga;\n\n    echo $arga;\n\nendfunc;\n\n\nfunc test2 arga;\n\n    echo $arga;\n\n    set arga override;\n\n    echo $arga;\n\nendfunc;\n\n\ntest1 test;\n",
      "hash": "b97a4ee2821dc5c29ac386696c0069e8a0fd78c3521ed7d345cec2ad6762aeaf"
    },
    "/usr/bin/test-array": {
      "perm": "root:root:755",
      "content": "#!/bin/shell\n\n\nfunc listdir dir;\n\n    set list ${ls -c $dir};\n\n    set len ${count $list};\n\n    set i 0;\n\n    set sep \"/\";\n\n    if $dir == \"/\";\n        set sep \"\";\n    endif;\n\n    while $i < $len;\n\n        fromindex item $list $i;\n\n        set item \"{$dir}{$sep}{$item}\";\n\n        echo $item;\n\n        if $item is dir;\n            listdir \"$item\";\n        endif;\n\n        sum i 1;\n\n    endwhile;\n\nendfunc;\n\nlistdir $0;\n",
      "hash": "31d7d109b2109d8a888cbaa5dcb04ecdbe8278e8a5706cdb3a15b2c987f84fad"
    },
    "/usr/bin/test-return": {
      "perm": "root:root:755",
      "content": "#!/bin/shell\n\nreturn \"AAH\";\n",
      "hash": "172c0e5c47d73f00da0d985bc3e2703fecc075bd19659e8f8c3b7dbf8b0a90ef"
    },
    "/usr/bin/test-conway": {
      "perm": "root:root:755",
      "content": "#!/bin/shell\n\nfunc conway;\n    perfstart conway;\n    set rows ${count $grid};\n    set r 0;\n    set nextgrid $grid;\n    while $r < $rows;\n        set cols ${count ${fromindex $grid $r}};\n        set c 0;\n        set row \"[0,0,0,0,0,0,0,0,0,0]\";\n        while $c < $cols;\n\n            conwaycell $r $c next;\n\n            setindex row $row $c $next;\n\n            sum c 1;\n        endwhile;\n\n        setindex nextgrid $nextgrid $r $row;\n\n        sum r 1;\n    endwhile;\n    perfend conway;\n    return $nextgrid;\nendfunc;\n\nfunc conwaycell r c;\n    perfstart conwaycell;\n    get_surround $r $c surround;\n    get_cell $r $c alive;\n\n    set next $alive;\n\n    if $alive > 0;\n        if $surround > 3;\n            set next 0;\n        endif;\n        if $surround < 2;\n            set next 0;\n        endif;\n    endif;\n    if $alive < 1;\n        if $surround == 3;\n            set next 1;\n        endif;\n    endif;\n    perfend conwaycell;\n\n    return $next;\n\n    # fromindex row $grid $r;\n\n    # setindex row $row $c $next;\n\n    # setindex nextgrid $nextgrid $r $row;\n    \nendfunc;\n\nfunc get_surround r c;\n    perfstart surround;\n    set ro -1;\n    set sum 0;\n    while $ro < 2;\n        set co -1;\n        set rr $r;\n        sum rr $ro;\n        \n        fromindex row $grid $rr;\n\n        perfstart surround_col;\n        while $co < 2;\n            # perfstart while_co;\n\n            set cc $c;\n            sum cc $co;\n\n            fromindex val $row $cc;\n\n            # get_cell 0 0 val;\n            \n            if $ro == 0;\n                if $co == 0;\n                    set val 0;\n                endif;\n            endif;\n            \n            sum sum $val;\n            sum co 1;\n            \n            # perfend while_co;\n        endwhile;\n        # perfend while_co;\n        perfend surround_col;\n        # perfout while_co;\n        sum ro 1;\n    endwhile;\n    perfend surround;\n    return $sum;\nendfunc;\n\nfunc get_cell r c;\n    return ${fromindex ${fromindex $grid $r} $c};\nendfunc;\n\nfunc output grid;\n    perfstart output;\n    set rows ${count $grid};\n    set r 0;\n    set txt \"\";\n    while $r < $rows;\n        # log r;\n        fromindex row $grid $r;\n        # log $row;\n        set cols ${count $row};\n        set c 0;\n        while $c < $cols;\n            fromindex cell $row $c;\n            set t \"░░\";\n            if $cell == 1;\n                set t \"▓▓\";\n            endif;\n            set txt \"{$txt}$t\";\n\n            sum c 1;\n        endwhile;\n        \n        set txt \"$txt\\n\";\n\n        sum r 1;\n    endwhile;\n    perfend output;\n    # clear;\n    echo \"\\033[j$run\\n$txt\";\n\nendfunc;\n\n\nset grid '[\n    [0,0,0,0,0,0,0,0,0,0],\n    [0,0,0,1,0,0,0,0,0,0],\n    [0,0,0,0,1,0,0,0,0,0],\n    [0,0,1,1,1,0,0,0,0,0],\n    [0,0,0,0,0,0,0,0,0,0],\n    [0,0,0,0,0,0,0,0,0,0],\n    [0,0,0,0,0,0,0,0,0,0],\n    [0,0,0,0,0,0,0,0,0,0],\n    [0,0,0,0,0,0,0,0,0,0],\n    [0,0,0,0,0,0,0,0,0,0]\n]';\n\n\n#echo ${count $grid};\n\n#echo \"Grid 1: ${fromindex $grid 1}\";\n\n# fromindex row $grid 1;\n\n# echo \"Row: $row\";\n\n# setindex row $row 1 2;\n\n# echo \"Row: $row\";\n\n# setindex grid $grid 1 $row;\n\n# echo \"Grid 1: ${fromindex $grid 1}\";\n\nfunc buildgrid x y;\n    if x < 1;\n        set x 10;\n    endif;\n    if y < 1;\n        set y $x;\n    endif;\n\n    set grid \"[]\";\n    set r 0;\n\n    while $r < $y;\n        set c 0;\n        set row \"[]\";\n\n        while $c < $x;\n\n            setindex row $row $c 0;\n\n            sum c 1;\n        endwhile;\n\n        setindex grid $grid $r $row;\n        sum r 1;    \n    endwhile;\n\n    return $grid;\n\nendfunc;\n\n\nset run 0;\n\n# buildgrid 10 10 tgrid;\n\n# echo $tgrid;\n\n# sleep 10;\n\nwhile $run < 10;\n    output $grid;\n    conway grid;\n    sum run 1;\nendwhile;\n",
      "hash": "6b4f4ec913ca39fa94a2283e691040605dbf00fa583bdca623405a0664f7eb66"
    },
    "/usr/bin/help": {
      "perm": "root:root:755",
      "content": "#!/bin/shell\n\nif \"/etc/shell/help\" is file;\n    cat /etc/shell/help;\nendif;\n\necho \"   /= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\\\\\";\necho \"  /= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\\\\\";\necho \" ||                                                               ||\";\necho \" ||     Welcome to TSOS                            (by wlf.io)    ||\";\necho \" ||                                                               ||\";\necho \" ||                                                               ||\";\necho \" ||      This site mimics a rudimentry nix like commandline       ||\";\necho \" ||                                                               ||\";\necho \" ||        Commands available:                                    ||\";\necho \" ||                                                               ||\";\n\nsplit paths $path \";\";\n\nset len ${count $paths};\n\nset index 0;\n\nset bins \"[]\";\n\nwhile $index < $len;\n\n    set newbins ${fromindex ${ls -c ${fromindex $paths $index}} 0};\n\n    append bins $bins $newbins;\n\n    sum index $index 1;\nendwhile;\n\nset index 0;\nset len ${count $bins};\n\nset str \"\";\n\nwhile $index < $len;\n\n    fromindex bin $bins $index;\n\n    set extra \"\";\n    \n    if not $index % 4;\n        set bin \" || $bin\";\n        if $index > 0;\n            set extra \"  ||\\n\";\n        endif;\n    endif;\n\n    len binl $bin;\n\n    set tab \"\";\n    if $binl < 16;\n        set tab \"{$tab}\\t\";\n        if $binl < 8;\n            set tab \"{$tab}\\t\";\n        endif;\n    endif;\n\n    set str \"{$str}{$extra}{$bin}{$tab}\";\n\n    sum index $index 1;\n\nendwhile;\n\n#echo $bins;\n\nmod mod $index 4;\n\nset ll 0;\n\nif $mod > 0;\n    sub ll 4 $mod;\nendif;\n\nwhile $ll > 0;\n\n    set str \"{$str}\\t\\t\";\n\n    sub ll $ll 1;\nendwhile;\n\necho \"$str  ||\";\n\necho \" ||                                                               ||\";\necho \" || commands usually support the --help argument for further info ||\";\necho \" ||                                                               ||\";\necho \"  \\\\= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =/\";\necho \"   \\\\= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =/\";\n",
      "hash": "0157559211c4702f29ee359932570744e3c42ef5b5c539d284a376cfbea761e0"
    },
    "/bin/args": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 560:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass args extends base_1.default {\n    start(_args) {\n        this.endOutput(JSON.stringify(this.rawArgs));\n    }\n}\nexports.default = args;\n\n\n/***/ }),\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(560);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "cca95580c88bd3cec8b4259b58dc2b19bd0415069a3efed520913072108b2a4a"
    },
    "/bin/cat": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 861:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass cat extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: cat [path]...\n Print out the contents of files`;\n    }\n    start(args) {\n        this.endOutput(args.map(a => {\n            try {\n                return this.system.fileSystem.read(a);\n            }\n            catch (e) {\n                return \"cat: \" + e;\n            }\n        }));\n    }\n}\nexports.default = cat;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(861);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "bb57e5c9b95a07346469c28fc8560861126c05d552887115130819c15eeaa507"
    },
    "/bin/cd": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 260:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass cd extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: cd [path]\n Change the current directory to another`;\n    }\n    start(args) {\n        const proc = this.proc.parent;\n        console.log(args);\n        let dir = (args[0] == \"-\" ? proc === null || proc === void 0 ? void 0 : proc.system.user.getEnv(\"LAST_DIR\") : args[0]) || \"/\";\n        if (dir.length < 1)\n            dir = \"/\";\n        proc === null || proc === void 0 ? void 0 : proc.system.user.setEnv(\"LAST_DIR\", proc === null || proc === void 0 ? void 0 : proc.fileSystem.cwd);\n        proc === null || proc === void 0 ? void 0 : proc.fileSystem.setCwd(args[0] || \"/\");\n        this.endOutput(\"\");\n    }\n}\nexports.default = cd;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(260);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "d210a02953c0c33b2ffa1ce3f476b4d246d9bfc6432509981f6327fb28daf211"
    },
    "/bin/chmod": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 453:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass chmod extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.permSet = null;\n        this.permsAdd = true;\n        this.permTargets = [];\n        this.perms = [];\n    }\n    start(args) {\n        if (args.length < 2) {\n            return this.fail(\"useage : chmod [options] [...paths]\");\n        }\n        try {\n            this.calcPerms(args.shift() || \"\");\n            this.setPerms(args);\n        }\n        catch (e) {\n            this.fail(e);\n        }\n        this.end(\"\");\n    }\n    setPerms(paths) {\n        paths.forEach(p => {\n            const permSet = this.permSet || this.calcNewPerm(p);\n            this.system.fileSystem.chmod(p, permSet);\n        });\n    }\n    calcNewPerm(path) {\n        const oldStr = this.system.fileSystem.getPerm(path).permString;\n        const old = oldStr.split(\"\");\n        let a = parseInt(old.pop() || \"0\") || 0;\n        let g = parseInt(old.pop() || \"0\") || 0;\n        let u = parseInt(old.pop() || \"0\") || 0;\n        if (this.permTargets.includes(\"a\"))\n            a = this.byteAdd(a, this.perms, this.permsAdd);\n        if (this.permTargets.includes(\"g\"))\n            g = this.byteAdd(g, this.perms, this.permsAdd);\n        if (this.permTargets.includes(\"u\"))\n            u = this.byteAdd(u, this.perms, this.permsAdd);\n        return `0${u}${g}${a}`;\n    }\n    byteAdd(perm, set, and) {\n        set.forEach(s => {\n            if (and) {\n                perm = perm | s;\n            }\n            else {\n                if (perm & s)\n                    perm = perm ^ s;\n            }\n        });\n        return perm;\n    }\n    calcPerms(perm) {\n        if (/^[0-7]{3,4}$/.test(perm)) {\n            this.permSet = perm;\n        }\n        else {\n            const minus = perm.includes(\"-\");\n            const plus = perm.includes(\"+\");\n            const parts = perm.split(plus ? \"+\" : \"-\");\n            const t = (parts[0] || \"uga\").split(\"\").filter(i => i.length == 1 && /^[uga]+$/.test(i));\n            const p = (parts[1] || \"\").split(\"\").filter(i => i.length == 1 && /^[rwx]+$/.test(i));\n            if (plus === minus || parts.length != 2 || p.length < 1) {\n                throw `perm must be <uga>(+/-)[rwx] (e.g +x, u-rx, ug+rw) or 0777 octal format\\n${JSON.stringify(parts)}\\n${JSON.stringify(t)}\\n${JSON.stringify(p)}\\n${plus ? \"+\" : \"-\"}`;\n            }\n            this.permsAdd = plus;\n            this.permTargets = t;\n            const map = {\n                \"r\": 4,\n                \"w\": 2,\n                \"x\": 1,\n            };\n            this.perms = p.map(t => map[t] || 0);\n        }\n    }\n}\nexports.default = chmod;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(453);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "d22ac7e23c4e436436570d5575e074aa5d7e7580583b3e78f86fd9ec3e27273f"
    },
    "/bin/chown": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 402:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass chown extends base_1.default {\n    start(_args) {\n        this.fail(\"Todo: chown\");\n    }\n}\nexports.default = chown;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(402);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "faa9d91b25a5bbb47c9033c9a56cfdc33113b9c332219b18f1bc2836a8f13874"
    },
    "/bin/clear": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 638:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass clear extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: clear\n Clear the screen`;\n    }\n    start(_args) {\n        this.endOutput(\"\\u001B[J\");\n    }\n}\nexports.default = clear;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(638);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "7fe80bd7c8ba1f91ae67c216c64faddd59db1794d5de76df349f954679ce0bbe"
    },
    "/bin/conway": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 192:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst EscapeCodes_1 = __importDefault(__webpack_require__(497));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass conway extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.frames = 100;\n        this.gridSizeX = 50;\n        this.gridSizeY = 50;\n        this.dataFile = null;\n        this.sleep = 10;\n        this.random = false;\n        this.teams = 1;\n        this.helpText = ` Usage: conway [options]...\n An implementation of conways game of life with immigrant feature\n\n\\t-g #\\t\\t\\tset grid size x and y\n\\t-x #\\t\\t\\tset grid size x\n\\t-y #\\t\\t\\tset grid size y\n\\t-d=path\\t\\tload specified datafile as starting state\n\\t-f #\\t--frames #\\trun simulation for specified ammount of frames ( default 100 )\n\\t-s #\\t--speed=#\\tset time to sleep between frames in ms ( speed ) ( default 10 )\n\\t-t #\\t\\t\\tset team count\n\\t-r\\t\\t\\trandomize starting state`;\n    }\n    handleFlag(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"g\":\n                this.gridSizeX = parseInt(arg || \"50\") || 50;\n                this.gridSizeY = this.gridSizeX;\n                return true;\n            case \"y\":\n                this.gridSizeY = parseInt(arg || \"50\") || 50;\n                return true;\n            case \"x\":\n                this.gridSizeX = parseInt(arg || \"50\") || 50;\n                return true;\n            case \"d\":\n                this.dataFile = arg;\n                return true;\n            case \"f\":\n                this.frames = parseInt(arg || \"100\") || 100;\n                return true;\n            case \"s\":\n            case \"speed\":\n                this.sleep = parseInt(arg || \"10\");\n                if (this.sleep == NaN)\n                    this.sleep = 10;\n                return true;\n            case \"t\":\n                this.teams = parseInt(arg || \"1\");\n                if (this.teams == NaN)\n                    this.teams = 1;\n                return true;\n            case \"r\":\n                this.random = true;\n                break;\n        }\n        return false;\n    }\n    buildGrid(sizeY, sizeX) {\n        const grid = [];\n        let y = 0;\n        for (y = 0; y < sizeY; y++) {\n            grid[y] = [];\n            let x = 0;\n            for (x = 0; x < sizeX; x++) {\n                grid[y][x] = 0;\n            }\n        }\n        return grid;\n    }\n    setGlider(grid) {\n        grid[3][3] = 1;\n        grid[4][4] = 1;\n        grid[5][2] = 1;\n        grid[5][3] = 1;\n        grid[5][4] = 1;\n    }\n    readFileToGrid(file, grid) {\n        file = this.fs.read(file);\n        const lines = file.split(\"\\n\").map(l => l.trim().split(/[ \\t]+/).filter(l => l.length)).filter(l => l.length == 2);\n        for (const line of lines) {\n            const y = parseInt(line[0] || \"0\") || 0;\n            const x = parseInt(line[1] || \"0\") || 0;\n            if (y < 0 || y >= grid.length)\n                continue;\n            const row = grid[y];\n            if (x < 0 || x >= row.length)\n                continue;\n            row[x] = 1;\n        }\n    }\n    randomizeGrid(grid) {\n        for (let y = 0; y < grid.length; y++) {\n            const row = grid[y];\n            for (let x = 0; x < row.length; x++) {\n                row[x] = Math.floor(Math.random() * (this.teams + 1));\n            }\n        }\n    }\n    async start(_args) {\n        let grid = this.buildGrid(this.gridSizeY, this.gridSizeX);\n        if (this.dataFile) {\n            this.readFileToGrid(this.dataFile, grid);\n        }\n        else if (this.random) {\n            this.randomizeGrid(grid);\n        }\n        else {\n            this.setGlider(grid);\n        }\n        while (this.frames-- > 0) {\n            this.outputGrid(grid);\n            grid = await this.conway(grid);\n            await (new Promise(res => window.setTimeout(() => res(1), this.sleep)));\n        }\n        this.end(\"\");\n    }\n    outputGrid(grid) {\n        let str = `${EscapeCodes_1.default.ESC}[J${this.frames}\\n`;\n        let last = 0;\n        for (const row of grid) {\n            for (const col of row) {\n                str += this.colourise(col ? \"▓▓\" : \"░░\", col, last);\n                last = col;\n            }\n            str += \"\\n\";\n        }\n        this.output(str);\n    }\n    colourise(str, team, lastTeam) {\n        if (this.teams == 1 || lastTeam == team)\n            return str;\n        let col = 0;\n        switch (team) {\n            case 1:\n                col = 31;\n                break;\n            case 2:\n                col = 34;\n                break;\n            case 3:\n                col = 32;\n                break;\n            case 4:\n                col = 33;\n                break;\n        }\n        return `${EscapeCodes_1.default.ESC}[${col}m${str}`;\n    }\n    async conway(grid) {\n        const nextGrid = this.buildGrid(this.gridSizeY, this.gridSizeX);\n        for (let y = 0; y < grid.length; y++) {\n            const row = grid[y];\n            for (let x = 0; x < row.length; x++) {\n                const cell = row[x];\n                const surround = this.sumSurround(grid, y, x);\n                let next = cell;\n                if (cell) {\n                    if (surround.teamCount(cell) > 3 || surround.teamCount(cell) < 2)\n                        next = 0;\n                }\n                else {\n                    next = surround.has3();\n                }\n                nextGrid[y][x] = next;\n            }\n        }\n        return nextGrid;\n    }\n    sumSurround(grid, y, x) {\n        const surround = new Surround();\n        for (const yo of [-1, 0, 1]) {\n            for (const xo of [-1, 0, 1]) {\n                if (xo == 0 && yo == 0)\n                    continue;\n                const cell = this.getGridCell(grid, y + yo, x + xo);\n                if (cell)\n                    surround.push(cell);\n            }\n        }\n        return surround;\n    }\n    getGridCell(grid, y, x) {\n        while (y < 0)\n            y += grid.length;\n        while (y >= grid.length)\n            y -= grid.length;\n        const row = grid[y];\n        while (x < 0)\n            x += row.length;\n        while (x >= row.length)\n            x -= row.length;\n        return row[x];\n    }\n}\nexports.default = conway;\nclass Surround {\n    constructor() {\n        this.cells = [];\n        this.count = {};\n    }\n    teamCount(team) {\n        return this.count[team] || 0;\n    }\n    has3() {\n        if (this.cells.length == 3) {\n            const t = Object.keys(this.count);\n            if (t.length == 1)\n                return parseInt(t[0]);\n            if (t.length == 3)\n                return parseInt(t[Math.floor(Math.random() * 3)]);\n            return parseInt(this.count[t[0]] > this.count[t[1]] ? t[0] : t[1]);\n        }\n        return 0;\n    }\n    push(c) {\n        this.cells.push(c);\n        this.count[c] = (this.count[c] || 0) + 1;\n    }\n}\n\n\n/***/ }),\n\n/***/ 497:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass EscapeCodes {\n}\nexports.default = EscapeCodes;\nEscapeCodes.NULL = \"\\u0000\";\nEscapeCodes.SOH = \"\\u0001\";\nEscapeCodes.STX = \"\\u0002\";\nEscapeCodes.ETX = \"\\u0003\";\nEscapeCodes.EOT = \"\\u0004\";\nEscapeCodes.ENQ = \"\\u0005\";\nEscapeCodes.ACK = \"\\u0006\";\nEscapeCodes.BEL = \"\\u0007\";\nEscapeCodes.BS = \"\\u0008\";\nEscapeCodes.HT = \"\\u0009\";\nEscapeCodes.LF = \"\\u000A\";\nEscapeCodes.VT = \"\\u000B\";\nEscapeCodes.FF = \"\\u000C\";\nEscapeCodes.CR = \"\\u000D\";\nEscapeCodes.CAN = \"\\u0018\";\nEscapeCodes.ESC = \"\\u001B\";\nEscapeCodes.DEL = \"\\u007F\";\nEscapeCodes.BELL = EscapeCodes.BEL;\nEscapeCodes.BACKSPACE = EscapeCodes.BS;\nEscapeCodes.TAB = EscapeCodes.HT;\nEscapeCodes.NEWLINE = EscapeCodes.LF;\nEscapeCodes.CANCEL = EscapeCodes.CAN;\nEscapeCodes.DELETE = EscapeCodes.DEL;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(192);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "a4f77cda93c1dab6d466959bc0056973453f9571a3c688a5a1244a0e88fcd27b"
    },
    "/bin/cp": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 405:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass cp extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: cp [options]... [source] [destination]\n Copy file from source to destionation\n\n\\t-f\\t\\t\\tforce`;\n        this.force = false;\n    }\n    handleFlag(flag, _arg) {\n        switch (flag) {\n            case \"f\":\n                this.force = true;\n                break;\n        }\n        return false;\n    }\n    start(args) {\n        if (args.length != 2) {\n            return this.fail(\"useage : cp <flags> [source] [destination]\");\n        }\n        const from = args[0];\n        const to = args[1];\n        if (!this.system.fileSystem.isFile(from)) {\n            return this.fail(\"can only copy files for now\");\n        }\n        try {\n            this.system.fileSystem.cp(from, to, this.force);\n            this.endOutput(\"\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = cp;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(405);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "375d8b1fe4124fedcd08825ea9f5a1ff56d55259c0ef1fc66a02777abcf6fdd7"
    },
    "/bin/date": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 572:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass date extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: date [option]...\n Print current date\n\n\\t-n\\t-e\\t\\tdo not append trailing new line`;\n        this.trail = \"\\n\";\n    }\n    handleFlag(flag, _arg) {\n        switch (flag) {\n            case \"e\":\n            case \"n\":\n                this.trail = \"\";\n                break;\n        }\n        return false;\n    }\n    start(_args) {\n        const date = new Date();\n        this.endOutput(date.toISOString() + this.trail);\n    }\n}\nexports.default = date;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(572);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "e18f95b1c0329c3af06a9444c39ad79bcf0303d8bb65e729ed44e81206cb5038"
    },
    "/bin/echo": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 928:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass echo extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: echo [option]... [text]...\n Echo specified text\n\n\\t-n\\t-e\\t\\tdo not append trailing new line`;\n        this.newLine = true;\n    }\n    handleFlag(flag, _arg) {\n        switch (flag.toLowerCase()) {\n            case \"n\":\n            case \"e\":\n                this.newLine = false;\n                break;\n        }\n        return false;\n    }\n    start(args) {\n        this.endOutput(args.join(\" \") + (this.newLine ? \"\\n\" : \"\"));\n    }\n}\nexports.default = echo;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(928);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "7cf9ac019fbd80966e88f6f772285beca43931ba765c7c6aed83c4b9be1a002a"
    },
    "/bin/exit": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 595:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass exit extends base_1.default {\n    start(_args) {\n        var _a;\n        (_a = this.proc.parent) === null || _a === void 0 ? void 0 : _a.end(\"\");\n        this.endOutput(\"\");\n    }\n}\nexports.default = exit;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(595);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "034944e6135c56951e5bfcd62396a9def0743d6100875fa3848e4c0b8633bda4"
    },
    "/bin/find": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 917:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass find extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: find [option]... [path]...\n Find files system entries matching flags\n\n\\t-n\\t-e\\t\\tdo not append trailing new line`;\n        this.newLine = true;\n        this.maxDepth = 999;\n        this.name = \"\";\n        this.type = \"a\";\n        this.perm = \"\";\n        this.user = \"\";\n        this.group = \"\";\n        this.types = [\"a\", \"f\", \"d\"];\n        this.errors = [];\n    }\n    handleFlag(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"name\":\n            case \"n\":\n                this.name = arg;\n                return true;\n            case \"type\":\n                if (this.types.includes(arg)) {\n                    this.type = arg;\n                }\n                return true;\n            case \"maxdepth\":\n                this.maxDepth = parseInt(arg) || 0;\n                return true;\n            case \"perm\":\n                this.perm = arg;\n                return true;\n            case \"user\":\n                this.user = arg;\n                return true;\n            case \"group\":\n                this.group = arg;\n                return true;\n        }\n        return false;\n    }\n    loadPerm(arg) {\n    }\n    start(args) {\n        if (this.errors.length) {\n            return this.fail(this.errors.join(\"\\n\"));\n        }\n        this.readDir(args.shift() || \".\", 1);\n    }\n    readDir(path, depth) {\n        if (depth > this.maxDepth)\n            return;\n        depth++;\n        for (const entry of this.fs.list(path)) {\n        }\n    }\n}\nexports.default = find;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(917);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "0fa13a5a2e147d0c1d2da00adfd0b56bf1a677bb71f7011507d2a5eb5d09f6db"
    },
    "/bin/head": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 492:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass head extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: head [option]... [path]...\n print out lines of a file starting from the beginning\n\n\\t-n\\t\\t\\tnumber of lines to show ( default 5 )`;\n        this.lines = 5;\n    }\n    start(args) {\n        const out = [];\n        args.forEach(a => {\n            out.push(a + \":\");\n            out.push(this.head(a));\n            out.push(\"\");\n        });\n        out.pop();\n        if (out.length == 2)\n            this.endOutput(out[1] + \"\\n\");\n        else\n            this.endOutput([...out, \"\"]);\n    }\n    head(path) {\n        try {\n            const parts = this.system.fileSystem.read(path).split(\"\\n\");\n            return parts.slice(0, this.lines).join(\"\\n\");\n        }\n        catch (e) {\n            return \"head: \" + e;\n        }\n    }\n}\nexports.default = head;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(492);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "9ab1f064ea16a605dfd6b30006e8fe07d646081f85f037117700469f2d77ba88"
    },
    "/bin/hostname": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 887:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass hostname extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: hostname [option]...\n print the hostname\n\n\\t-e\\t-n\\t\\tdo not add a trailing newline`;\n        this.endChar = \"\\n\";\n    }\n    handleFlag(flag, _arg) {\n        switch (flag) {\n            case \"e\":\n            case \"n\":\n                this.endChar = \"\";\n                break;\n        }\n        return false;\n    }\n    start(_args) {\n        this.endOutput(location.hostname + this.endChar);\n    }\n}\nexports.default = hostname;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(887);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "45bbf9dd91e06813510b3f054816626b53982e136f48e69b89b36facc03c538d"
    },
    "/bin/ls": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 426:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass ls extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.showAll = false;\n        this.longForm = false;\n        this.humanReadable = false;\n        this.colour = true;\n        this.helpText = ` Usage: ls [option]... [path]...\n List files/directories and information about them.\n\n\\t-a\\t--all\\t\\tshow hidden entries ( those starting with . )\n\\t-l\\t\\t\\toutput long format with more information\n\\t-h\\t--human\\t\\tshow file sizes and permissions in more a\n\\t\\t\\t\\tmore readable format\n\\t-c\\t\\t\\tdisable colouring of output`;\n    }\n    handleFlag(flag, _arg) {\n        switch (flag.toLowerCase()) {\n            case \"a\":\n            case \"all\":\n                this.showAll = true;\n                break;\n            case \"l\":\n                this.longForm = true;\n                break;\n            case \"h\":\n            case \"human\":\n                this.humanReadable = true;\n                break;\n            case \"c\":\n                this.colour = false;\n                break;\n        }\n        return false;\n    }\n    start(args) {\n        if (args.length < 1) {\n            args.push(\".\");\n        }\n        const result = args.map(a => [a, this.list(a)]);\n        if (result.length == 1) {\n            this.output(result[0][1]);\n            this.output(\"\\n\");\n            this.end(result[0][1]);\n        }\n        else {\n            const r2 = [];\n            result.forEach(r => {\n                r2.push([r[0]]);\n                r2.push(...r[1]);\n            });\n            this.output(r2);\n            this.output(\"\\n\");\n            this.end(r2);\n        }\n    }\n    list(path) {\n        let list = [];\n        try {\n            list = this.system.fileSystem.list(path);\n        }\n        catch (e) {\n            this.fail(e);\n            return [];\n        }\n        list.sort();\n        const res = this.system.fileSystem.resolve(path);\n        const triml = res == \"/\" ? 0 : 1;\n        if (res != \"/\")\n            list.unshift(res + \"/..\");\n        list.unshift(res + \"/.\");\n        if (!this.showAll) {\n            list = list.filter(l => !l.substr(res.length + 1).startsWith(\".\"));\n        }\n        if (this.longForm) {\n            list = list.map(l => {\n                const dir = this.system.fileSystem.isDir(l);\n                const perm = this.system.fileSystem.getPerm(l);\n                const date = (new Date(perm.modifyTime * 1000));\n                const dateStr = date.toDateString().split(\" \");\n                dateStr.shift();\n                if (dateStr[2] == (new Date()).getFullYear().toString()) {\n                    dateStr.pop();\n                    dateStr.push(date.toTimeString().substr(0, 5));\n                }\n                return [\n                    this.humanReadable ? perm.longPermString : perm.permString,\n                    \"0\",\n                    perm.owner,\n                    perm.group,\n                    dir ? \"0\" : this.getFileSize(l),\n                    dateStr.join(\" \"),\n                    this.colouriseFile(l.substr(res.length + triml), dir, perm)\n                ];\n            });\n        }\n        else {\n            list = [list.map(l => {\n                    const dir = this.system.fileSystem.isDir(l);\n                    const perm = this.system.fileSystem.getPerm(l);\n                    return this.colouriseFile(l.substr(res.length + triml), dir, perm);\n                })];\n        }\n        return list;\n    }\n    getFileSize(path) {\n        let size = this.system.fileSystem.read(path).length;\n        if (this.humanReadable) {\n            let s = \"\";\n            if (size > (1024 * 1024)) {\n                size /= (1024 * 1024);\n                s = \"M\";\n            }\n            else if (size > 1024) {\n                size /= 1024;\n                s = \"K\";\n            }\n            return `${size.toFixed(1)}${s}B`;\n        }\n        else {\n            return size.toString();\n        }\n    }\n    colouriseFile(name, dir, access) {\n        if (!this.colour)\n            return name;\n        if (dir) {\n            name = \"\\u001B[34m\" + name;\n        }\n        else {\n            if (access.canExecute(this.system.user)) {\n                name = \"\\u001B[32m\" + name;\n            }\n        }\n        return name + \"\\u001B[0m\";\n    }\n}\nexports.default = ls;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(426);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "deff872fad1d7fbdb771229ff665b8f5d8aaf85fe0d027dcbde1636245c3cb6c"
    },
    "/bin/mkdir": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 754:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass mkdir extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: mkdir [option]... [path]...\n Create directories\n\n\\t-s\\t\\t\\tsilence, suppress errors ( does not mean it will succeed )\n\\t-p\\t\\t\\tmake parent directories as required`;\n        this.silent = false;\n        this.makeParent = false;\n    }\n    handleFlag(flag) {\n        switch (flag.toLowerCase()) {\n            case \"s\":\n                this.silent = true;\n                break;\n            case \"p\":\n                this.makeParent = true;\n                break;\n        }\n        return false;\n    }\n    start(args) {\n        args.forEach(a => {\n            try {\n                this.system.fileSystem.mkdir(a);\n            }\n            catch (e) {\n                if (!this.silent || this.makeParent)\n                    this.output(e);\n            }\n        });\n        this.endOutput(\"\");\n    }\n}\nexports.default = mkdir;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(754);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "a44e891e123dcee64e34af4ae6de5829ab3fe462a6b503c3b5db0a122f8d2354"
    },
    "/bin/mv": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 198:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass mv extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: mv [options]... [source] [destination]\n Move file from source to destionation\n\n\\t-f\\t\\t\\tforce`;\n        this.force = false;\n    }\n    handleFlag(flag, _arg) {\n        switch (flag) {\n            case \"f\":\n                this.force = true;\n                break;\n        }\n        return false;\n    }\n    start(args) {\n        if (args.length != 2) {\n            return this.fail(\"useage : mv <flags> [source] [destination]\");\n        }\n        const from = args[0];\n        const to = args[1];\n        if (!this.system.fileSystem.isFile(from)) {\n            return this.fail(\"can only move files for now\");\n        }\n        this.system.fileSystem.mv(from, to, this.force);\n        this.endOutput(\"\");\n    }\n}\nexports.default = mv;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(198);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "e4d712cad3c8bdb12d0bfd67cbed764f2a99c4dab781becd133de14d22fd16dd"
    },
    "/bin/pid": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 580:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass pid extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: pid\n print the (P)rocess (ID)dentifier number of the current process.`;\n    }\n    start(_args) {\n        var _a;\n        this.endOutput(((_a = this.proc.parent) === null || _a === void 0 ? void 0 : _a.pid.toString()) || \"n/a\");\n    }\n}\nexports.default = pid;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(580);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "bb7b4cf5eeb1231683ef7fd93dda02f9e0580f757ce662761b78d7fa62ca0ba9"
    },
    "/bin/ping": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 483:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass ping extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: ping [address]\n ping and address to get communication time.`;\n        this.count = 5;\n    }\n    start(args) {\n        if (args.length != 1) {\n            this.fail(\"useage : ping <flags> [address]\");\n        }\n        this.doPing(args[0], this.count);\n    }\n    async doPing(address, count) {\n        const r = [];\n        while (--count >= 0) {\n            const t = await this.ping(address);\n            this.output(t.toString() + \"\\n\");\n            r.push(t);\n            await (new Promise(res => window.setTimeout(() => res(1), 1000)));\n        }\n        this.endOutput(\"\");\n    }\n    async ping(address) {\n        const t = performance.now();\n        try {\n            await fetch(address);\n        }\n        catch (e) {\n        }\n        return performance.now() - t;\n    }\n}\nexports.default = ping;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(483);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "af28d14b7d718136e8e7a47f151b80aee3db2318a9014315d412c1d94aa92b1c"
    },
    "/bin/printenv": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 24:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass printenv extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: printenv\n List environment variables and their values.`;\n    }\n    start(_args) {\n        this.endOutput([...this.system.user.listEnv(), []]);\n    }\n}\nexports.default = printenv;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(24);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "5ee72d34c08175c315f8f92359b7991dac8f8831d3379290d999797c9708fc15"
    },
    "/bin/pwd": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 252:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass pwd extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: pwd [option]...\n Output the current working directory\n\n\\t-a\\t\\t\\tabbreviate the path if possible ( e.g. /home/user/file > ~/file)\n\\t-e\\t-n\\t\\tdo not add trailing new line`;\n        this.abreviate = false;\n        this.trail = \"\\n\";\n    }\n    handleFlag(flag, _arg) {\n        switch (flag.toLowerCase()) {\n            case \"a\":\n                this.abreviate = true;\n                break;\n            case \"e\":\n            case \"n\":\n                this.trail = \"\";\n                break;\n        }\n        return false;\n    }\n    start(_args) {\n        let cwd = this.system.fileSystem.cwd;\n        if (this.abreviate) {\n            cwd = this.system.fileSystem.abreviate(cwd);\n        }\n        this.endOutput(cwd + this.trail);\n    }\n}\nexports.default = pwd;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(252);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "82cd47352434da8c1fe0ef4f6544b21f4c3604d2d7fabd738d393c21ada6cc66"
    },
    "/bin/remenv": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 271:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass printenv extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: remenv [name]\n Delete the named environment variable`;\n    }\n    start(args) {\n        args.forEach(a => { var _a; return (_a = this.proc.parent) === null || _a === void 0 ? void 0 : _a.system.user.remEnv(a); });\n        this.endOutput(\"\");\n    }\n}\nexports.default = printenv;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(271);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "77510affdff506b8f74f4a9333447e52cafd3096efd7298b2948356369a3fa2f"
    },
    "/bin/rm": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 429:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass rm extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: rm [option]... [path]...\n Delete files/directories.\n\n\\t-f\\t\\t\\tforce\n\\t-r\\t\\t\\tdelete recursivley`;\n        this.recursive = false;\n        this.force = false;\n    }\n    handleFlag(flag, _arg) {\n        switch (flag.toLowerCase()) {\n            case \"f\":\n                this.force = true;\n                break;\n            case \"r\":\n                this.recursive = true;\n                break;\n        }\n        return false;\n    }\n    start(args) {\n        args.forEach(a => this.rm(a));\n        this.endOutput(this.force ? \"\" : \"\");\n    }\n    rm(path) {\n        const fs = this.system.fileSystem;\n        const fpath = fs.resolve(path);\n        if (fs.exists(fpath)) {\n            const dir = fs.isDir(fpath);\n            if (dir) {\n                if (!this.recursive)\n                    this.output(`rm: cannot remove '${fpath}': Is a Direcotry\\n`);\n                else {\n                    const children = this.getChildren(fpath);\n                    children.forEach(p => this.rm(p));\n                    try {\n                        fs.delete(fpath);\n                    }\n                    catch (e) {\n                        this.output(`rm: failed to remove '${fpath}': ${e}\\n`);\n                    }\n                }\n            }\n            else {\n                try {\n                    fs.delete(fpath);\n                }\n                catch (e) {\n                    this.output(`rm: failed to remove '${fpath}': ${e}\\n`);\n                }\n            }\n        }\n    }\n    getChildren(path) {\n        const fs = this.system.fileSystem;\n        const paths = [];\n        fs.list(path, false).forEach(p => {\n            paths.push(p);\n        });\n        return paths;\n    }\n}\nexports.default = rm;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(429);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "5ea68d22bc83ebd37a6dcf9e9da40707141dc626889a46e68fd0b940dc52fb3f"
    },
    "/bin/setenv": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 579:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass setenv extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: setenv [name] [value]\n Set an environment variable`;\n    }\n    start(args) {\n        var _a;\n        if (args.length != 2) {\n            this.fail(\"Expected 2 arguments, [name] [value]\");\n        }\n        (_a = this.proc.parent) === null || _a === void 0 ? void 0 : _a.system.user.setEnv(args[0], args[1]);\n        this.endOutput(\"\");\n    }\n}\nexports.default = setenv;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(579);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "68dbb1dd868a8e245663fab54c8f95546d8619f753fb040220f49548ce1ebd7e"
    },
    "/bin/shell": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 849:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst EscapeCodes_1 = __importDefault(__webpack_require__(497));\nconst LexerStream_1 = __importDefault(__webpack_require__(93));\nconst base_1 = __importDefault(__webpack_require__(334));\nconst ShellCompleter_1 = __importDefault(__webpack_require__(718));\nconst ShellRunner_1 = __importDefault(__webpack_require__(16));\nclass shell extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.motd = false;\n        this.inputStr = \"\";\n        this.savedInputStr = \"\";\n        this.historyIndex = -1;\n        this.column = 0;\n        this.script = null;\n        this.command = false;\n        this.test = false;\n        this.vars = {};\n        this.shellRunning = null;\n        this.subRunners = [];\n        this.profile = false;\n        this.helpText = ` Usage: shell [option]... [args]...\n List files/directories and information about them.\n\n\\t-s\\t--script\\texecute script specified after flag\n\\t-c\\t\\t\\texecute the command specified after the flag\n\\t-p\\t--profile\\tload the profile script at start`;\n    }\n    handleFlag(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"motd\":\n                this.motd = true;\n                break;\n            case \"s\":\n            case \"script\":\n                this.script = arg;\n                return true;\n            case \"c\":\n            case \"command\":\n                this.command = true;\n                break;\n            case \"t\":\n            case \"test\":\n                this.test = true;\n                break;\n            case \"p\":\n            case \"profile\":\n                this.profile = true;\n                break;\n        }\n        return false;\n    }\n    passInput(input, ident) {\n        if (ident == \"user\") {\n            this.userInput(input, ident);\n        }\n        else {\n            this.output(input);\n        }\n    }\n    end(output) {\n        if (this.shellRunning != null) {\n            this.shellRunning.end();\n            this.shellRunning = null;\n            if (!this.script && !this.command) {\n                return;\n            }\n        }\n        super.end(output);\n    }\n    get process() {\n        return this.proc;\n    }\n    userInput(input, ident) {\n        var _a;\n        if (typeof input != \"string\") {\n            throw \"USER INPUT ARRAY???\";\n        }\n        if (input == EscapeCodes_1.default.CANCEL) {\n            if (this.shellRunning == null && this.subRunners.length < 1) {\n                if (this.script == null && this.command == false) {\n                    this.inputStr = \"\";\n                    this.column = 0;\n                    this.prompt();\n                }\n            }\n            else {\n                (_a = this.shellRunning) === null || _a === void 0 ? void 0 : _a.input(input, ident);\n                this.subRunners.forEach(s => s.input(input, ident));\n            }\n            return;\n        }\n        if (this.shellRunning != null) {\n            this.shellRunning.input(input, ident);\n        }\n        else {\n            switch (input) {\n                case \"Enter\":\n                    this.output(`${EscapeCodes_1.default.ESC}[0m`);\n                    this.output(\"\\n\");\n                    if (this.inputStr.length) {\n                        this.historyIndex = -1;\n                        if (!this.inputStr.startsWith(\" \")) {\n                            this.system.fileSystem.append(\"~/.shell_history\", this.inputStr + \"\\n\");\n                        }\n                        this.runInput(this.inputStr)\n                            .then(() => {\n                            this.inputStr = \"\";\n                            this.column = 0;\n                            this.prompt();\n                        });\n                    }\n                    else {\n                        this.prompt();\n                    }\n                    break;\n                case \"Tab\":\n                    if (this.column == this.inputStr.length) {\n                        const completer = new ShellCompleter_1.default(this.inputStr, this.proc);\n                        completer.predict()\n                            .then(result => {\n                            if (result.predictions.length > 1) {\n                                this.output(\"\\n\" + result.predictions.join(\"\\t\") + \"\\n\");\n                                this.prompt().then(() => {\n                                    this.output(this.inputStr);\n                                });\n                            }\n                            else {\n                                this.addToInput(result.predictions[0]);\n                            }\n                        }).catch(_e => {\n                            this.output(EscapeCodes_1.default.BELL);\n                        });\n                    }\n                    break;\n                case \"Backspace\":\n                    if (this.inputStr.length > 0 && this.column > 0) {\n                        this.inputStr = this.inputStr.substring(0, this.column - 1) + this.inputStr.substring(this.column);\n                        this.column--;\n                        this.output(EscapeCodes_1.default.BACKSPACE);\n                    }\n                    else {\n                        this.output(EscapeCodes_1.default.BELL);\n                    }\n                    break;\n                case \"Delete\":\n                    if (this.inputStr.length > 0 && this.column < this.inputStr.length) {\n                        this.inputStr = this.inputStr.substring(0, this.column) + this.inputStr.substring(this.column + 1);\n                        this.output(EscapeCodes_1.default.DELETE);\n                    }\n                    else {\n                        this.output(EscapeCodes_1.default.BELL);\n                    }\n                    break;\n                case \"ArrowUp\":\n                case \"ArrowDown\":\n                    this.history(input == \"ArrowUp\" ? 1 : -1);\n                    break;\n                case \"ArrowLeft\":\n                case \"ArrowRight\":\n                    this.nav(input == \"ArrowLeft\" ? -1 : 1);\n                    break;\n                case \"Home\":\n                    this.output((new Array(0 - this.column).join(\"\")));\n                    break;\n                case \"End\":\n                    break;\n                default:\n                    this.addToInput(input);\n                    break;\n            }\n            this.system.debug(\"Shell Column\", this.column.toString());\n        }\n    }\n    async runInput(input, mute = false, tag = \"\") {\n        const runner = new ShellRunner_1.default(this, input, \"shell_exec\", undefined, tag || input);\n        runner.test = this.test;\n        this.shellRunning = runner;\n        runner.mute = mute;\n        await runner.run();\n        this.clearScopedVars();\n        this.shellRunning = null;\n    }\n    addToInput(ch) {\n        this.inputStr = this.inputStr.substring(0, this.column) + ch + this.inputStr.substring(this.column);\n        if (this.column < this.inputStr.length - ch.length) {\n            this.output(`${EscapeCodes_1.default.ESC}[K`);\n            this.output(this.inputStr.substr(this.column));\n            this.output((new Array(this.inputStr.length - this.column)).join(`${EscapeCodes_1.default.ESC}[D`));\n        }\n        else {\n            this.output(ch);\n        }\n        this.column += ch.length;\n    }\n    history(dir) {\n        if (this.historyIndex < 0) {\n            this.savedInputStr = this.inputStr;\n        }\n        this.historyIndex += dir;\n        let item = \"\";\n        if (this.historyIndex == -1) {\n            item = this.savedInputStr;\n        }\n        if (this.historyIndex >= 0) {\n            const history = this.system.fileSystem.read(\"~/.shell_history\").trim().split(\"\\n\").filter((h, i, a) => {\n                return i < 1 || a[i - 1] != h;\n            });\n            item = history[history.length - this.historyIndex - 1];\n        }\n        if (this.historyIndex < -1)\n            this.historyIndex = -1;\n        if (item.length > 0 || this.historyIndex == -1) {\n            this.inputStr = \"\";\n            this.output((new Array(this.column + 1)).join(`${EscapeCodes_1.default.ESC}[D`));\n            this.output(`${EscapeCodes_1.default.ESC}[K`);\n            this.column = 0;\n            if (item.length > 0)\n                this.addToInput(item);\n        }\n    }\n    nav(dir) {\n        let dirC = \"C\";\n        if (dir < 0) {\n            if (this.column == 0)\n                return;\n            this.column--;\n            dirC = \"D\";\n            dir *= -1;\n        }\n        else {\n            if (this.column == this.inputStr.length)\n                return;\n            this.column++;\n        }\n        this.output(`${EscapeCodes_1.default.ESC}[${dir}${dirC}`);\n    }\n    async start(args) {\n        args.forEach((v, i) => this.setVar((i).toString(), v, \"\"));\n        this.setVar(\"ARGC\", args.length.toString(), \"\");\n        await this.setup();\n        if (this.script != null) {\n            const input = this.system.fileSystem.read(this.script);\n            await this.runInput(input, undefined, \"script: \" + this.script);\n            this.endOutput(\"\");\n        }\n        else if (this.command) {\n            console.log(\"SHELL COMMAND\", args.join(\" \"));\n            await this.runInput(args.join(\" \"), undefined, \"command: \" + args.join(\" \"));\n            this.endOutput(\"\");\n        }\n        else if (this.motd) {\n            try {\n                if (this.system.fileSystem.exists(\"/etc/shell/motd\")) {\n                    await this.runInput(this.system.fileSystem.read(\"/etc/shell/motd\"), undefined, \"motd\");\n                }\n            }\n            catch (e) {\n            }\n            this.prompt();\n        }\n        else {\n            this.prompt();\n        }\n    }\n    async setup() {\n        try {\n            if (this.profile && this.system.fileSystem.exists(\"/etc/shell/profile\")) {\n                const test = this.test;\n                this.test = false;\n                try {\n                    await this.runInput(this.system.fileSystem.read(\"/etc/shell/profile\"), this.script != null || this.command, \"/etc/shell/profile\");\n                }\n                catch (e) {\n                    console.log(e);\n                }\n                this.test = test;\n            }\n        }\n        catch (e) {\n            console.log(\"Shell Setup Error\", e);\n        }\n        return Promise.resolve();\n    }\n    async prompt() {\n        const p = await this.varReplace(this.getVar(\"PS1\", \"\") || \"$USER@$HOSTNAME:$CWD\\\\$\\\\$ \");\n        this.output(p);\n    }\n    listVars() {\n        const vars = this.system.user.listEnv();\n        const ex = vars.map(v => v[0]);\n        Object.entries(this.vars).filter(v => !ex.includes(v[0]))\n            .forEach(e => vars.push(e));\n        return vars;\n    }\n    clearScopedVars() {\n        for (const k in this.vars) {\n            if (k.startsWith(\"SCOPE_\")) {\n                delete this.vars[k];\n            }\n        }\n    }\n    getVar(name, prefix) {\n        var _a, _b;\n        name = name.toUpperCase().trim();\n        prefix = (prefix + name).toUpperCase().trim();\n        const v = (_a = this.vars[prefix]) !== null && _a !== void 0 ? _a : ((_b = this.vars[name]) !== null && _b !== void 0 ? _b : this.system.user.getEnv(name));\n        return v;\n    }\n    setVar(name, value, prefix) {\n        name = (prefix + name).toUpperCase().trim();\n        this.vars[name] = value;\n        return value;\n    }\n    remVar(name, prefix) {\n        name = (prefix + name).toUpperCase().trim();\n        if (this.vars.hasOwnProperty(name)) {\n            delete this.vars[name];\n        }\n    }\n    async varReplace(t, scopePrefix = \"\", line = 0) {\n        const stream = new LexerStream_1.default(t);\n        let o = \"\";\n        let inVar = false;\n        let escape = false;\n        let varName = \"\";\n        let varIsCmd = false;\n        let varIsCmdBC = 0;\n        let wrapped = false;\n        while (!stream.eof()) {\n            const ch = stream.next();\n            if (escape) {\n                escape = false;\n                o += ch;\n            }\n            else if (inVar) {\n                if (varIsCmd) {\n                    if (ch == \"}\" && varIsCmdBC == 0) {\n                        varIsCmd = false;\n                        inVar = false;\n                        if (varName.length) {\n                            const runner = new ShellRunner_1.default(this, varName, \"shell_exec\", scopePrefix);\n                            this.subRunners.push(runner);\n                            runner.mute = true;\n                            let out = await runner.run();\n                            this.subRunners.pop();\n                            if (out instanceof Array) {\n                                out = JSON.stringify(out);\n                            }\n                            o += out;\n                        }\n                    }\n                    else {\n                        if (ch == \"{\")\n                            varIsCmdBC++;\n                        if (ch == \"}\")\n                            varIsCmdBC--;\n                        varName += ch;\n                    }\n                }\n                else if (/[a-zA-Z0-9_-]/.test(ch)) {\n                    varName += ch;\n                }\n                else if (varName.length < 1 && ch == \"{\") {\n                    varIsCmd = true;\n                    varIsCmdBC = 0;\n                }\n                else {\n                    if (varName.length) {\n                        o += this.getVar(varName, scopePrefix);\n                    }\n                    if (wrapped) {\n                        if (ch != \"}\")\n                            throw `wrapped string token should end with '}' : Line ${line}`;\n                    }\n                    else\n                        o += ch;\n                    inVar = false;\n                }\n            }\n            else if (ch == \"\\\\\") {\n                escape = true;\n            }\n            else if (ch == \"$\") {\n                inVar = true;\n                varName = \"\";\n            }\n            else if (ch == \"{\" && stream.peek() == \"$\") {\n                stream.next();\n                inVar = true;\n                varName = \"\";\n                wrapped = true;\n            }\n            else {\n                o += ch;\n            }\n        }\n        if (inVar) {\n            o += this.getVar(varName, scopePrefix);\n        }\n        return Promise.resolve(o);\n    }\n}\nexports.default = shell;\n\n\n/***/ }),\n\n/***/ 683:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShellBlock = void 0;\nconst ShellLexer_1 = __importStar(__webpack_require__(886));\nclass ShellBlocker {\n    constructor(script) {\n        this.blocks = [];\n        this.lexer = ShellLexer_1.default.createFromString(script);\n    }\n    getBlocks() {\n        if (this.blocks.length < 1) {\n            this.buildBlocks();\n        }\n        return [...this.blocks];\n    }\n    buildBlocks() {\n        this.blocks = [];\n        let currentBlock = new ShellBlock();\n        while (!this.lexer.eof()) {\n            const next = this.lexer.next();\n            if (next == null)\n                continue;\n            if (next.value == \"\" && next.raw != '\"\"' && next.raw != \"''\") {\n                continue;\n            }\n            if (next.raw == \";\") {\n                this.blocks.push(currentBlock);\n                currentBlock = new ShellBlock();\n                continue;\n            }\n            if (next.type == ShellLexer_1.TokenType.spec) {\n                if ((next.value == \">\" || next.value == \">>\" || next.value == \"|\") && !this.isGreaterThan(next.value, currentBlock)) {\n                    const append = next.value == \">>\";\n                    currentBlock.passOutput = true;\n                    this.blocks.push(currentBlock);\n                    currentBlock = new ShellBlock();\n                    currentBlock.passInput = true;\n                    if (next.value == \"|\")\n                        continue;\n                    next.value = \"write\";\n                    next.raw = \"write\";\n                    currentBlock.push(next);\n                    if (append) {\n                        currentBlock.push({ type: ShellLexer_1.TokenType.ident, raw: \"-a\", value: \"-a\", line: next.line, column: next.column });\n                    }\n                    continue;\n                }\n            }\n            currentBlock.push(next);\n        }\n        this.blocks.push(currentBlock);\n    }\n    isGreaterThan(val, block) {\n        if (val != \">\")\n            return false;\n        if (block.tokens.length < 2 || block.tokens.length > 3)\n            return false;\n        switch (block.tokens[0].value.trim().toLowerCase()) {\n            case \"if\":\n            case \"while\":\n                return true;\n            default:\n                return false;\n        }\n    }\n}\nexports.default = ShellBlocker;\nclass ShellBlock {\n    constructor(...tokens) {\n        this.line = 0;\n        this.tokens = [];\n        this.passInput = false;\n        this.passOutput = false;\n        this.tokens = [...tokens];\n    }\n    push(token) {\n        if (this.tokens.length < 1)\n            this.line = token.line;\n        this.tokens.push(token);\n    }\n    clone() {\n        const block = new ShellBlock(...this.tokens);\n        block.passInput = this.passInput;\n        block.passOutput = this.passOutput;\n        return block;\n    }\n}\nexports.ShellBlock = ShellBlock;\n\n\n/***/ }),\n\n/***/ 718:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ShellLexer_1 = __importStar(__webpack_require__(886));\nclass ShellCompleter {\n    constructor(input, proc) {\n        this.lexer = ShellLexer_1.default.createFromString(input);\n        this.input = input;\n        this.system = proc.system;\n        this.process = proc;\n    }\n    async predict() {\n        const tokens = this.lexer.getAll();\n        const last = tokens.pop() || null;\n        let current = true;\n        const text = (last === null || last === void 0 ? void 0 : last.value) || \"\";\n        if (last) {\n            let incompleteString = last.type == ShellLexer_1.TokenType.string && (last.raw.charAt(0) != last.raw.charAt(last.raw.length - 1));\n            if (this.input.endsWith(\" \") && !incompleteString) {\n                current = false;\n            }\n        }\n        let predictions = [];\n        if (tokens.length == 0 && current) {\n            predictions = [...(await this.predictBins(text))];\n        }\n        else {\n            predictions = [...(await this.predictFiles(current ? text : \"\"))];\n        }\n        if (predictions.length == 0) {\n            throw \"no results\";\n        }\n        if (predictions.length == 1) {\n            predictions = [this.trimPrediction(predictions[0], current ? last : null)];\n        }\n        return { txt: current ? ((last === null || last === void 0 ? void 0 : last.raw) || \"\") : \"\", predictions };\n    }\n    trimPrediction(prediction, last) {\n        let r = (last === null || last === void 0 ? void 0 : last.raw) || \"\";\n        let l = r.length;\n        while (--l >= 0) {\n            if (prediction.startsWith(r.substr(l))) {\n                prediction = prediction.substr(r.length - l);\n            }\n        }\n        if ((last === null || last === void 0 ? void 0 : last.type) != ShellLexer_1.TokenType.string) {\n            prediction = prediction.split(\" \").join(\"\\\\ \");\n        }\n        return prediction;\n    }\n    async predictBins(txt) {\n        const bins = (await this.getBins()).filter(t => t.startsWith(txt));\n        if (bins.length == 1 && bins[0] == txt)\n            throw \" \";\n        return bins;\n    }\n    async getBins() {\n        const path = this.system.user.getEnv(\"path\") || \"/bin\";\n        const paths = path.split(\";\").map(p => p.trim());\n        let bins = [];\n        for (const p of paths) {\n            const proc = this.process.createProcess(\"ls\", [\"-c\", p]);\n            const resp = await proc.run();\n            if (resp instanceof Array) {\n                const first = resp.pop();\n                if (first instanceof Array) {\n                    bins = [...bins, ...first];\n                }\n            }\n        }\n        return bins;\n    }\n    async predictFiles(txt) {\n        txt = txt || \"./\";\n        const parts = txt.split(\"/\");\n        const start = parts.pop() || \"\";\n        const parent = parts.join(\"/\") || (txt.startsWith(\"/\") ? \"/\" : \".\");\n        const proc = this.process.createProcess(\"ls\", [\"-c\", parent]);\n        const resp = await proc.run();\n        console.log(\"F PRED\", txt, parts, start, parent, resp);\n        let predictions = [];\n        if (resp instanceof Array) {\n            const first = resp.pop();\n            if (first instanceof Array) {\n                predictions = [...first];\n            }\n        }\n        return predictions.filter(p => p.startsWith(start));\n    }\n}\nexports.default = ShellCompleter;\n\n\n/***/ }),\n\n/***/ 886:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TokenType = void 0;\nconst LexerStream_1 = __importDefault(__webpack_require__(93));\nclass ShellLexer {\n    constructor(stream) {\n        this.pos = -1;\n        this.stream = stream;\n    }\n    static createFromString(input) {\n        return new ShellLexer(new LexerStream_1.default(input));\n    }\n    getAll() {\n        this.rewind();\n        const tokens = [];\n        while (!this.eof()) {\n            const next = this.next();\n            if (next)\n                tokens.push(next);\n        }\n        return tokens;\n    }\n    isWhitespace(ch, nl = true) {\n        return ((nl ? \"\\n\" : \"\") + \" \\r\\t\").indexOf(ch) >= 0;\n    }\n    isAToZ0To9(ch) {\n        return /[a-zA-Z0-9]/.test(ch);\n    }\n    isNotAToZ0To9(ch) {\n        return !this.isAToZ0To9(ch) && !this.isWhitespace(ch);\n    }\n    isSpecial(ch) {\n        return [\";\", \"&\", \">\", \"|\", \"<\", \"[\", \"]\", \"=\", \"!\"].includes(ch);\n    }\n    readWhile(func) {\n        let str = \"\";\n        while (!this.stream.eof() && func(this.stream.peek())) {\n            str += this.stream.next();\n        }\n        return str;\n    }\n    all() {\n        this.rewind();\n        let next = this.next();\n        const all = [];\n        while (next != null) {\n            all.push(next);\n            next = this.next();\n        }\n        return all;\n    }\n    next() {\n        this.readWhile(ch => this.isWhitespace(ch));\n        if (this.stream.eof())\n            return null;\n        const ch = this.stream.peek();\n        const chAfter = this.stream.peek(1);\n        const line = this.stream.line + 1;\n        const column = this.stream.column;\n        if (ch == \"#\")\n            return this.skipOneLineComment();\n        if (ch == \"/\") {\n            if (chAfter == \"/\")\n                return this.skipOneLineComment();\n            else if (chAfter == \"*\")\n                return this.skipMultiLineComment();\n        }\n        this.pos++;\n        if (ch == \"'\" || ch == '\"')\n            return this.readWrapped(ch, TokenType.string, line, column);\n        if (ch == \"$\")\n            return this.readVarToken(TokenType.ident, line, column);\n        else if (this.isSpecial(ch))\n            return this.readSpecial(TokenType.spec, line, column);\n        else\n            return this.readIdentifier(TokenType.ident, line, column);\n    }\n    skipOneLineComment() {\n        this.readWhile((ch) => ch != \"\\n\");\n        this.stream.next();\n        return this.next();\n    }\n    skipMultiLineComment() {\n        this.readWhile((ch) => {\n            return !(ch == \"/\" && this.stream.peek(-1) == \"*\");\n        });\n        this.stream.next();\n        return this.next();\n    }\n    readVarToken(type, line, column) {\n        const func = this.stream.peek(1) == \"{\";\n        let depth = 0;\n        const raw = this.readEscaped((ch, n) => {\n            if (func) {\n                if (ch == \"{\")\n                    depth++;\n                if (ch == \"}\")\n                    depth--;\n                return ch == \"}\" && depth < 1;\n            }\n            else {\n                return this.isWhitespace(n) || this.isSpecial(n);\n            }\n        });\n        return {\n            type,\n            value: raw,\n            raw,\n            line,\n            column\n        };\n    }\n    readWrapped(wrapper, type, line, column) {\n        const raw = this.readEscaped(wrapper, true);\n        return {\n            type: type,\n            value: raw.substring(1, raw.length - 1),\n            raw: raw,\n            line,\n            column,\n        };\n    }\n    readIdentifier(type, line, column) {\n        const raw = this.readEscaped((_ch, n) => this.isWhitespace(n) || this.isSpecial(n));\n        return {\n            type: type,\n            value: raw,\n            raw: raw,\n            line,\n            column,\n        };\n    }\n    readSpecial(type, line, column) {\n        const raw = this.readWhile(ch => this.isNotAToZ0To9(ch));\n        return {\n            type: type,\n            value: raw,\n            raw: raw,\n            line,\n            column,\n        };\n    }\n    readEscaped(end, skipFirst = false, escape = \"\\\\\") {\n        let escaped = skipFirst;\n        let str = \"\";\n        while (!this.stream.eof()) {\n            const ch = this.stream.next();\n            if (escaped) {\n                str += this.resolveEscapedChar(ch);\n                escaped = false;\n            }\n            else if (ch == escape && escape != \"\") {\n                escaped = true;\n            }\n            else {\n                str += ch;\n                if (typeof end == \"string\") {\n                    if (ch == end) {\n                        break;\n                    }\n                }\n                else {\n                    if (end(ch, this.stream.peek())) {\n                        break;\n                    }\n                }\n            }\n        }\n        return str;\n    }\n    resolveEscapedChar(char) {\n        switch (char) {\n            case \"n\":\n                return \"\\n\";\n            case \"\\\\\":\n                return \"\\\\\\\\\";\n            case \"t\":\n                return \"\\t\";\n            case \"$\":\n                return \"\\\\$\";\n            case \"0\":\n                let num = \"\";\n                let p = this.stream.peek();\n                if (/[0-7]/.test(p)) {\n                    num += this.stream.next();\n                }\n                p = this.stream.peek();\n                if (/[0-7]/.test(p)) {\n                    num += this.stream.next();\n                }\n                const o = parseInt(num, 8);\n                return decodeURIComponent(\"%\" + o.toString(16));\n            default:\n                return char;\n        }\n    }\n    peek(count = 0) {\n        const pos = this.pos;\n        let token = this.next();\n        while (count--) {\n            token = this.next();\n        }\n        this.rewindTo(pos);\n        return token;\n    }\n    eof() {\n        return this.peek() == null;\n    }\n    rewind() {\n        this.stream.rewind();\n        this.pos = -1;\n    }\n    rewindTo(pos) {\n        this.rewind();\n        while (this.pos < pos) {\n            this.next();\n        }\n    }\n}\nexports.default = ShellLexer;\nvar TokenType;\n(function (TokenType) {\n    TokenType[\"string\"] = \"string\";\n    TokenType[\"ident\"] = \"ident\";\n    TokenType[\"spec\"] = \"spec\";\n})(TokenType = exports.TokenType || (exports.TokenType = {}));\n\n\n/***/ }),\n\n/***/ 16:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst EscapeCodes_1 = __importDefault(__webpack_require__(497));\nconst ShellBlocker_1 = __importDefault(__webpack_require__(683));\nclass ShellRunner {\n    constructor(shell, script, ident, scopePrefix = \"\", tag = \"\") {\n        this.tag = \"\";\n        this.currentProc = null;\n        this.currentProcIdent = \"\";\n        this.running = false;\n        this.test = false;\n        this.block = 0;\n        this.blocks = [];\n        this.funcs = {};\n        this.funcStack = [];\n        this.queuedOutputs = [];\n        this.currentBlock = null;\n        this.mute = false;\n        this.shell = shell;\n        this.tag = tag || script.substr(0, 15);\n        this.blocker = new ShellBlocker_1.default(script);\n        this.ident = ident;\n        this.scopePrefix = scopePrefix;\n        this.perf = new PerfLog();\n    }\n    end() {\n        var _a;\n        (_a = this.currentProc) === null || _a === void 0 ? void 0 : _a.input(\"\\u0018\", \"user\");\n        this.currentProc = null;\n        this.running = false;\n    }\n    hookOut(_hook, _ident) {\n        throw new Error(\"Method not implemented.\");\n    }\n    input(input, ident) {\n        var _a, _b, _c;\n        switch (ident) {\n            case \"user\":\n                if (input == EscapeCodes_1.default.CANCEL) {\n                    this.running = false;\n                }\n                if (!((_b = (_a = this.currentBlock) === null || _a === void 0 ? void 0 : _a.passInput) !== null && _b !== void 0 ? _b : false) && !this.mute) {\n                    (_c = this.currentProc) === null || _c === void 0 ? void 0 : _c.input(input, ident);\n                }\n                break;\n            case this.currentProcIdent:\n                this.output(input, ident);\n                break;\n            case this.currentProcIdent + \"_pass\":\n                this.queuedOutputs.push(input);\n                break;\n            default:\n                console.log(\"Shell runner lost input\", input, ident);\n                break;\n        }\n    }\n    output(output, _ident) {\n        if (this.mute)\n            return;\n        this.shell.input(output, this.ident);\n    }\n    async run() {\n        if (this.running)\n            throw \"running\";\n        this.perf = new PerfLog();\n        this.perf.start(\"run\");\n        this.running = true;\n        this.perf.start(\"blocking\");\n        this.blocks = this.blocker.getBlocks().filter(b => b.tokens.length);\n        this.perf.end(\"blocking\");\n        this.block = 0;\n        let args = [];\n        try {\n            while (this.block < this.blocks.length) {\n                if (!this.running)\n                    return \"\";\n                const block = this.blocks[this.block].clone();\n                this.currentBlock = block;\n                args = await this.runBlock(block, this.block, block.passInput ? this.queuedOutputs : [], block.passOutput);\n                this.block++;\n            }\n        }\n        catch (e) {\n            this.output(e.toString().trim() + ` : Line ${this.getBlockStartLine(this.block)}\\n`, \"error\");\n            console.log(this.blocks);\n        }\n        this.perf.end(\"run\");\n        if (this.shell.process.system.isDebug && this.tag.startsWith(\"script:\"))\n            console.log(this.tag + \"\\n\" + this.perf.perf().join(\"\\n\"));\n        this.shell.process.system.debug(\"runner time\", this.perf.total(\"run\"));\n        return Promise.resolve(args);\n    }\n    async runBlock(block, blockNumber, input, passOut) {\n        const tokes = block.tokens;\n        if (tokes.length < 1)\n            return \"\";\n        if (!this.running)\n            throw \"canceled\";\n        const vtokes = [];\n        for (const t of tokes) {\n            const r = await this.shell.varReplace(t.value, this.varScopePrefix, this.getBlockStartLineNumber(blockNumber));\n            vtokes.push(r);\n        }\n        if (this.test) {\n            this.output(JSON.stringify(tokes.map(t => t.value)) + \"\\n\", \"test\");\n            this.output(JSON.stringify(vtokes) + \"\\n\", \"test\");\n            return \"\";\n        }\n        const name = vtokes.shift() || \"\";\n        this.perf.start(\"internal\");\n        const internal = this.handleInternal(name, vtokes, blockNumber);\n        if (internal !== false) {\n            this.perf.end(\"internal\");\n            return internal;\n        }\n        this.perf.start(\"createproc\");\n        const proc = this.shell.process.createProcess(name, vtokes);\n        this.perf.end(\"createproc\");\n        this.currentProc = proc;\n        this.currentProcIdent = `${name}[${proc.pid}]`;\n        if (input.length) {\n            console.log(JSON.stringify(input));\n            while (input.length) {\n                proc.input(input.shift() || \"\", \"\");\n            }\n        }\n        else {\n            proc.input(\"\", \"\");\n        }\n        this.queuedOutputs = [];\n        proc.hookOut(this, this.currentProcIdent + (passOut ? \"_pass\" : \"\"));\n        try {\n            this.perf.start(\"proc\");\n            const arg = await proc.run();\n            this.perf.end(\"proc\");\n            return arg;\n        }\n        catch (e) {\n            throw e;\n        }\n    }\n    handleInternal(name, args, block) {\n        name = name.trim().toLowerCase();\n        if (name.startsWith(\":\"))\n            return \"\";\n        if (name == \"goto\")\n            return this.goto(args[0] || \"\", block);\n        if (name == \"endif\")\n            return \"\";\n        if (name == \"if\")\n            return this.conditional(args, block);\n        if (name == \"else\")\n            return this.skipElse(block);\n        if (name == \"set\")\n            return this.set(args, block);\n        if (name == \"len\")\n            return this.len(args, block);\n        if (name == \"count\")\n            return this.count(args, block);\n        if (name == \"sum\")\n            return this.math(args, (a, b) => a + b, name, block);\n        if (name == \"mult\")\n            return this.math(args, (a, b) => a * b, name, block);\n        if (name == \"div\")\n            return this.math(args, (a, b) => a / b, name, block);\n        if (name == \"sub\")\n            return this.math(args, (a, b) => a - b, name, block);\n        if (name == \"mod\")\n            return this.math(args, (a, b) => a % b, name, block);\n        if (name == \"pow\")\n            return this.math(args, (a, b) => a ^ b, name, block);\n        if (name == \"printvar\")\n            return this.printVar();\n        if (name == \"func\")\n            return this.registerFunc(args, block);\n        if (this.isFunc(name))\n            return this.runFunc(name, args, block);\n        if (name == \"return\")\n            return this.endFunc(args[0] || \"\", block);\n        if (name == \"endfunc\")\n            return this.endFunc(\"\", block);\n        if (name == \"while\")\n            return this.conditional(args, block, \"while\", \"endwhile\", null);\n        if (name == \"endwhile\")\n            return this.endWhile(block);\n        if (name == \"fromindex\")\n            return this.fromIndex(args, block);\n        if (name == \"setindex\")\n            return this.setIndex(args, block);\n        if (name == \"pop\")\n            return this.pop(args, block);\n        if (name == \"push\")\n            return this.push(args, block);\n        if (name == \"log\") {\n            console.log(this.getBlockStartLine(block), ...args);\n            return \"\";\n        }\n        if (name == \"debug\") {\n            this.shell.process.system.debug(args[0] || \"srd\", args[1] || null);\n            return \"\";\n        }\n        if (name == \"perfstart\") {\n            this.perf.start(args[0] || \"script\");\n            return \"\";\n        }\n        ;\n        if (name == \"perfend\") {\n            this.perf.end(args[0] || \"script\");\n            return \"\";\n        }\n        ;\n        if (name == \"perfout\") {\n            console.log(args[0], this.perf.getTimes(args[0]) || []);\n            return \"\";\n        }\n        ;\n        if (name == \"split\")\n            return this.split(args, block);\n        if (name == \"append\")\n            return this.append(args, block);\n        if (name == \"join\")\n            return this.join(args, block);\n        if (name == \"unique\")\n            return this.unique(args, block);\n        return false;\n    }\n    unique(args, block) {\n        if (![1, 2].includes(args.length)) {\n            throw `split needs 1 or 2 arguments: Line ${this.getBlockStartLine(block)}`;\n        }\n        let data = args.pop() || \"[]\";\n        const vr = args.pop() || null;\n        data = this.stringIffy([...(new Set(this.arrayIffy(data)))]);\n        if (vr) {\n            return this.set([vr, data], block);\n        }\n        return data;\n    }\n    append(args, block) {\n        if (![2, 3].includes(args.length)) {\n            throw `append needs 2 or 3 arguments: Line ${this.getBlockStartLine(block)}`;\n        }\n        const data2 = args.pop() || \"[]\";\n        const data1 = args.pop() || \"[]\";\n        const vr = args.pop() || null;\n        const data = this.stringIffy([...this.arrayIffy(data1), ...this.arrayIffy(data2)]);\n        if (vr) {\n            return this.set([vr, data], block);\n        }\n        return data;\n    }\n    split(args, block) {\n        if (![2, 3].includes(args.length)) {\n            throw `split needs 2 or 3 arguments: Line ${this.getBlockStartLine(block)}`;\n        }\n        const sep = args.pop() || \",\";\n        let data = args.pop() || \"\";\n        const vr = args.pop() || null;\n        data = this.stringIffy(data.split(sep));\n        if (vr) {\n            return this.set([vr, data], block);\n        }\n        return data;\n    }\n    join(args, block) {\n        if (![2, 3].includes(args.length)) {\n            throw `join needs 2 or 3 arguments: Line ${this.getBlockStartLine(block)}`;\n        }\n        const sep = args.pop() || \",\";\n        let data = args.pop() || \"\";\n        const vr = args.pop() || null;\n        data = this.arrayIffy(data).join(sep);\n        if (vr) {\n            return this.set([vr, data], block);\n        }\n        return data;\n    }\n    skipElse(block) {\n        let depth = 1;\n        const index = this.blocks.findIndex((b, i) => {\n            var _a;\n            if (i <= block)\n                return false;\n            const n = (((_a = b.tokens[0]) === null || _a === void 0 ? void 0 : _a.value) || \"\").trim().toLowerCase();\n            if (n == \"if\" || n == \"ifnot\")\n                depth++;\n            if (n == \"endif\") {\n                depth--;\n                if (depth < 1)\n                    return true;\n            }\n            return false;\n        });\n        if (index < 0)\n            throw `else needs endif: Line ${this.getBlockStartLine(block)}`;\n        this.block = index;\n        return \"\";\n    }\n    setIndex(args, block) {\n        var _a;\n        if (![3, 4].includes(args.length)) {\n            throw `setindex needs 3 or 4 arguments: Line ${this.getBlockStartLine(block)}`;\n        }\n        let value = args.pop() || \"\";\n        try {\n            value = JSON.parse(value);\n        }\n        catch (e) { }\n        let index = parseInt(args.pop() || \"\") || 0;\n        let str = (_a = args.pop()) !== null && _a !== void 0 ? _a : \"\";\n        const list = this.arrayIffy(str);\n        list[index] = (typeof value == \"string\") ? value : JSON.stringify(value);\n        str = this.stringIffy(list);\n        if (args.length == 1) {\n            return this.set([args[0], str], block);\n        }\n        return str;\n    }\n    fromIndex(args, block) {\n        var _a;\n        if (![2, 3].includes(args.length)) {\n            throw `fromindex needs 2 or 3 arguments: Line ${this.getBlockStartLine(block)}`;\n        }\n        let index = parseInt(args.pop() || \"\") || 0;\n        const str = (_a = args.pop()) !== null && _a !== void 0 ? _a : \"\";\n        const list = this.arrayIffy(str);\n        if (index < 0)\n            index += list.length;\n        if (index >= list.length)\n            index -= list.length;\n        const item = list[index] || \"\";\n        if (args.length == 1) {\n            return this.set([args[0], item], block);\n        }\n        return item;\n    }\n    pop(args, block) {\n        const arg = args[0] || \"\";\n        let val = this.getVar(arg);\n        let useVar = true;\n        if (val.length < 1) {\n            val = arg;\n            useVar = false;\n        }\n        const array = this.arrayIffy(val);\n        const result = array.pop() || \"\";\n        if (useVar) {\n            this.set([arg, this.stringIffy(array)], block);\n        }\n        return result;\n    }\n    push(args, block) {\n        const arg = args[0] || \"\";\n        let val = this.getVar(arg);\n        let useVar = true;\n        if (val.length < 1) {\n            val = arg;\n            useVar = false;\n        }\n        const array = this.arrayIffy(val);\n        array.push(args[1] || \"\");\n        if (useVar) {\n            this.set([arg, this.stringIffy(array)], block);\n        }\n        return \"\";\n    }\n    endWhile(block) {\n        var _a;\n        let i = block;\n        let depth = 1;\n        let index = null;\n        while (--i >= 0) {\n            const b = this.blocks[i];\n            const n = (((_a = b.tokens[0]) === null || _a === void 0 ? void 0 : _a.value) || \"\").trim().toLowerCase();\n            if (n == \"endwhile\")\n                depth++;\n            if (n == \"while\")\n                depth--;\n            if (n == \"while\" && depth < 1) {\n                index = i - 1;\n                break;\n            }\n        }\n        if (index == null) {\n            throw `endwhile needs while above: Line ${this.getBlockStartLine(block)}`;\n        }\n        else {\n            this.block = index;\n        }\n        return \"\";\n    }\n    get varScopePrefix() {\n        if (this.funcStack.length > 0) {\n            const s = this.funcStack[this.funcStack.length - 1];\n            return `scope_${s.func}_${this.funcStack.length}_`;\n        }\n        return this.scopePrefix;\n    }\n    endFunc(arg, block) {\n        const stack = this.funcStack.pop();\n        if (stack) {\n            this.block = stack.block;\n            if (stack.out) {\n                this.set([stack.out, arg || \"\"], block);\n            }\n        }\n        else {\n            this.block = this.blocks.length;\n        }\n        return arg;\n    }\n    runFunc(name, args, block) {\n        const func = this.funcs[name];\n        const toSet = [];\n        func.args.forEach((a, i) => {\n            toSet.push([a, args[i] || \"\"]);\n        });\n        this.block = func.block;\n        this.funcStack.push({ block: block, func: name, out: args.pop() || null });\n        toSet.forEach(t => this.set(t, block));\n        return \"\";\n    }\n    isFunc(name) {\n        return Object.keys(this.funcs).includes(name);\n    }\n    registerFunc(args, block) {\n        if (args.length < 1) {\n            throw `func must have a name: Line ${this.getBlockStartLine(block)}\\n`;\n        }\n        const name = args.shift() || \"\";\n        const index = this.blocks.findIndex((b, i) => {\n            var _a;\n            if (i <= block)\n                return false;\n            const n = (((_a = b.tokens[0]) === null || _a === void 0 ? void 0 : _a.value) || \"\").trim().toLowerCase();\n            if (n == \"func\")\n                throw `cannot nest funcs: : Line ${this.getBlockStartLine(block)}\\n`;\n            return n == \"endfunc\";\n        });\n        if (index < 1) {\n            throw \"func needs endfunc\";\n        }\n        this.funcs[name] = { block: block, endBlock: index, args: args };\n        this.block = index;\n        return \"\";\n    }\n    printVar() {\n        this.output([...this.shell.listVars(), []], \"printvar\");\n        return \"\";\n    }\n    goto(label, block) {\n        const index = this.blocks.findIndex(block => {\n            var _a;\n            return (((_a = block.tokens[0]) === null || _a === void 0 ? void 0 : _a.value) || \"\") == `:${label}`;\n        });\n        if (index < 1) {\n            throw `goto needs label :${label}: Line ${this.getBlockStartLine(block)}\\n`;\n        }\n        this.block = index;\n        return \"\";\n    }\n    len(args, block) {\n        if (![1, 2].includes(args.length)) {\n            throw `len can only take 1 or 2 variables: Line ${this.getBlockStartLine(block)}\\n`;\n        }\n        if (args.length == 2) {\n            return this.set([args[0], args[1].length.toString()], block);\n        }\n        else {\n            return args[0].length.toString();\n        }\n    }\n    count(args, block) {\n        if (![1, 2].includes(args.length)) {\n            throw `count can only take 1 or 2 variables: Line ${this.getBlockStartLine(block)}\\n`;\n        }\n        if (args.length == 2) {\n            return this.set([args[0], this.arrayIffy(args[1]).length.toString()], block);\n        }\n        else {\n            return this.arrayIffy(args[0]).length.toString();\n        }\n    }\n    getVar(name) {\n        return this.shell.getVar(name, this.varScopePrefix) || \"\";\n    }\n    math(args, func, name, block) {\n        if (![2, 3].includes(args.length)) {\n            throw `${name} can only take 2 or 3 arguments: Line ${this.getBlockStartLine(block)}\\n`;\n        }\n        let b = args.pop() || \"0\";\n        let a = args.pop() || \"0\";\n        a = parseFloat(a) || 0;\n        b = parseFloat(b) || 0;\n        const vr = args.pop() || null;\n        const result = func(a, b).toString();\n        if (vr !== null) {\n            return this.set([vr, result], block);\n        }\n        else {\n            return result;\n        }\n    }\n    set(args, block) {\n        if (args.length != 2) {\n            throw `set can only take 2 variables: : Line ${this.getBlockStartLine(block)}\\n`;\n        }\n        return this.shell.setVar(args[0], args[1], this.varScopePrefix);\n    }\n    conditional(args, block, start = \"if\", end = \"endif\", endAlt = \"else\") {\n        if (![1, 3, 4].includes(args.length)) {\n            throw `if can only take 1 or 3 or 4 variables: Line ${this.getBlockStartLine(block)}\\n`;\n        }\n        const len = args.length;\n        const b = args.pop() || \"0\";\n        const op = args.pop() || \"\";\n        const a = args.pop() || \"0\";\n        const mod = (args.pop() || \"\").trim().toLowerCase();\n        const intA = parseInt(a) || 0;\n        const intB = parseInt(b) || 0;\n        let pass = false;\n        if (len == 1) {\n            pass = intA != 0 || a.length > 0;\n        }\n        else {\n            switch (op) {\n                case \"==\":\n                case \"=\":\n                    pass = a == b;\n                    break;\n                case \"!=\":\n                    pass = a == b;\n                    break;\n                case \">\":\n                    pass = intA > intB;\n                    break;\n                case \">=\":\n                    pass = intA >= intB;\n                    break;\n                case \"<\":\n                    pass = intA < intB;\n                    break;\n                case \"<=\":\n                    pass = intA <= intB;\n                    break;\n                case \"%\":\n                    pass = (intA % intB) != 0;\n                    break;\n                case \"is\":\n                    pass = this.conditionalIs(a, b, block);\n                    break;\n                default:\n                    throw `Unrecognized operator: ${op}: Line ${this.getBlockStartLine(block)}\\n`;\n            }\n        }\n        if (mod == \"not\" || mod == \"!\") {\n            pass = !pass;\n        }\n        if (!pass) {\n            let depth = 1;\n            const index = this.blocks.findIndex((b, i) => {\n                var _a;\n                if (i <= block)\n                    return false;\n                const n = (((_a = b.tokens[0]) === null || _a === void 0 ? void 0 : _a.value) || \"\").trim().toLowerCase();\n                if (n == start)\n                    depth++;\n                if (n == end || (depth == 1 && n === endAlt))\n                    depth--;\n                return depth < 1 && (n == end || n === endAlt);\n            });\n            if (index < 1) {\n                throw `${start} needs ${end}: Line ${this.getBlockStartLine(block)}\\n`;\n            }\n            this.block = index;\n        }\n        return \"\";\n    }\n    conditionalIs(a, b, block) {\n        switch (b.toLowerCase()) {\n            case \"file\":\n                return this.shell.process.fileSystem.isFile(a.trim());\n            case \"exec\":\n            case \"executable\":\n                return this.shell.process.fileSystem.canExecute(a.trim()) && this.shell.process.fileSystem.isFile(a.trim());\n            case \"read\":\n            case \"readable\":\n                return this.shell.process.fileSystem.canRead(a.trim());\n            case \"write\":\n            case \"writeable\":\n                return this.shell.process.fileSystem.canWrite(a.trim());\n            case \"dir\":\n                return this.shell.process.fileSystem.isDir(a.trim());\n            case \"int\":\n                return this.shell.process.fileSystem.isDir(a);\n            case \"float\":\n                return this.shell.process.fileSystem.isDir(a);\n            default:\n                throw `Invlaid is param ${b}: Line ${this.getBlockStartLine(block)}\\n`;\n        }\n    }\n    getBlockStartLineNumber(block) {\n        var _a, _b;\n        return (((_b = (_a = this.blocks[block]) === null || _a === void 0 ? void 0 : _a.tokens[0]) === null || _b === void 0 ? void 0 : _b.line) || -1);\n    }\n    getBlockStartLine(block) {\n        var _a;\n        return this.getBlockStartLineNumber(block).toString() + \" \" + JSON.stringify((((_a = this.blocks[block]) === null || _a === void 0 ? void 0 : _a.tokens) || []).map(t => t.value));\n    }\n    arrayIffy(arg) {\n        const array = JSON.parse(arg);\n        if (!(array instanceof Array))\n            throw `failed to decord array`;\n        return array.map(a => ([\"string\"].includes(typeof a)) ? a : JSON.stringify(a));\n    }\n    stringIffy(arg) {\n        return JSON.stringify(arg.map(a => {\n            try {\n                return JSON.parse(a);\n            }\n            catch (_a) {\n                return a;\n            }\n        }));\n    }\n}\nexports.default = ShellRunner;\nclass PerfLog {\n    constructor() {\n        this.data = {};\n        this.starts = {};\n    }\n    start(k) {\n        this.starts[k] = performance.now();\n    }\n    end(k) {\n        const e = performance.now();\n        if (!this.data.hasOwnProperty(k))\n            this.data[k] = [];\n        this.data[k].push(e - (this.starts[k] || 9));\n    }\n    getTimes(k) {\n        return this.data[k] || [];\n    }\n    total(k) {\n        return this.getTimes(k).reduce((a, b) => a + b, 0);\n    }\n    count(k) {\n        return this.getTimes(k).length;\n    }\n    average(k) {\n        return this.total(k) / this.count(k);\n    }\n    perf() {\n        const s = Object.keys(this.data).map(k => {\n            return [\n                this.padTab(k, 3),\n                this.padTab(this.count(k), 3),\n                this.padTab(this.total(k), 3),\n                this.padTab(this.average(k), 3),\n            ].join(\"\");\n        });\n        s.unshift(\"Key\\t\\tcount\\t\\ttotal\\t\\taverage\");\n        return s;\n    }\n    padTab(txt, tabs) {\n        if (typeof txt != \"string\") {\n            if ((txt % 1) != 0)\n                txt = txt.toFixed(3);\n            txt = txt.toString();\n        }\n        const c = Math.ceil(((8 * tabs) - (txt.length)) / 8);\n        return txt + (new Array(c)).join(\"\\t\");\n    }\n}\n\n\n/***/ }),\n\n/***/ 497:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass EscapeCodes {\n}\nexports.default = EscapeCodes;\nEscapeCodes.NULL = \"\\u0000\";\nEscapeCodes.SOH = \"\\u0001\";\nEscapeCodes.STX = \"\\u0002\";\nEscapeCodes.ETX = \"\\u0003\";\nEscapeCodes.EOT = \"\\u0004\";\nEscapeCodes.ENQ = \"\\u0005\";\nEscapeCodes.ACK = \"\\u0006\";\nEscapeCodes.BEL = \"\\u0007\";\nEscapeCodes.BS = \"\\u0008\";\nEscapeCodes.HT = \"\\u0009\";\nEscapeCodes.LF = \"\\u000A\";\nEscapeCodes.VT = \"\\u000B\";\nEscapeCodes.FF = \"\\u000C\";\nEscapeCodes.CR = \"\\u000D\";\nEscapeCodes.CAN = \"\\u0018\";\nEscapeCodes.ESC = \"\\u001B\";\nEscapeCodes.DEL = \"\\u007F\";\nEscapeCodes.BELL = EscapeCodes.BEL;\nEscapeCodes.BACKSPACE = EscapeCodes.BS;\nEscapeCodes.TAB = EscapeCodes.HT;\nEscapeCodes.NEWLINE = EscapeCodes.LF;\nEscapeCodes.CANCEL = EscapeCodes.CAN;\nEscapeCodes.DELETE = EscapeCodes.DEL;\n\n\n/***/ }),\n\n/***/ 93:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass LexerStream {\n    constructor(input) {\n        this.lin = 0;\n        this.pos = 0;\n        this.col = 0;\n        this.input = input;\n    }\n    get position() {\n        return this.pos;\n    }\n    get line() {\n        return this.lin;\n    }\n    get column() {\n        return this.col;\n    }\n    next() {\n        const char = this.peek();\n        this.pos++;\n        if (char == \"\\n\") {\n            this.lin++;\n            this.col = 0;\n        }\n        else {\n            this.col++;\n        }\n        return char;\n    }\n    peek(count = 0) {\n        return this.input.charAt(this.pos + count);\n    }\n    eof() {\n        return this.peek() == \"\";\n    }\n    croak(error) {\n        return new Error(`[${this.line}:${this.col}] - ${error}`);\n    }\n    rewindTo(position) {\n        this.rewind();\n        while (this.pos < position) {\n            this.next();\n        }\n    }\n    rewind() {\n        this.pos = 0;\n        this.lin = 0;\n        this.col = 0;\n    }\n}\nexports.default = LexerStream;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(849);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "b26c748139e6fd4df5cd8cb11f0d41e94c01ad2f85f88cef2171a664a11cc19c"
    },
    "/bin/sleep": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 844:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass sleep extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: sleep [time]\n Pause for [time] ammount of seconds`;\n    }\n    start(args) {\n        setTimeout(() => {\n            this.endOutput(\"\");\n        }, (parseFloat(args[0]) || 1) * 1000);\n    }\n}\nexports.default = sleep;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(844);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "3799e6448ed4b1a2fdbcc10f025858625bf02ef7a28e76392b2d377c0fe03751"
    },
    "/bin/tail": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 10:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass tail extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: tail [option]... [path]...\n print out lines of a file starting from the end\n\n\\t-n\\t\\t\\tnumber of lines to show ( default 5 )`;\n        this.lines = 5;\n    }\n    start(args) {\n        const out = [];\n        args.forEach(a => {\n            out.push(a + \":\");\n            out.push(this.tail(a));\n            out.push(\"\");\n        });\n        out.pop();\n        if (out.length == 2)\n            out.shift();\n        this.endOutput(out);\n    }\n    tail(path) {\n        try {\n            const parts = this.system.fileSystem.read(path).split(\"\\n\");\n            let lines = this.lines;\n            if (parts[parts.length - 1] === \"\") {\n                lines++;\n            }\n            return parts.slice(lines * -1).join(\"\\n\");\n        }\n        catch (e) {\n            return \"tail: \" + e;\n        }\n    }\n}\nexports.default = tail;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(10);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "26d65824f6e6351f8627d7c48a8a27bcd27421004bd0d399fcda2a10207cd143"
    },
    "/bin/touch": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 261:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass touch extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: touch [option]... [path]...\n Create files\n\n\\t-s\\t\\t\\tsilent, suppress errors ( does not mean it will succeed )`;\n        this.silent = false;\n    }\n    handleFlag(flag) {\n        switch (flag.toLowerCase()) {\n            case \"s\":\n                this.silent = true;\n                break;\n        }\n        return false;\n    }\n    start(args) {\n        for (const a of args) {\n            try {\n                this.system.fileSystem.touch(a);\n            }\n            catch (e) {\n                if (!this.silent)\n                    return this.fail(e);\n            }\n        }\n        this.endOutput(\"\");\n    }\n}\nexports.default = touch;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(261);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "5ca994e1f0a571074eed13febb230d393340b9eba6e6b8341acf1ff3aed1d066"
    },
    "/bin/watch": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 410:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importStar(__webpack_require__(334));\nclass watch extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: watch [arguments]...\n run a command repeatedly to monitor its output`;\n        this.time = 2;\n    }\n    async start(_args) {\n        while (this.state == base_1.AppState.running) {\n            await this.watch();\n            await (new Promise(res => window.setTimeout(() => res(1), this.time * 1000)));\n        }\n        this.end(\"\");\n    }\n    async watch() {\n        const proc = this.proc.createProcess(\"shell\", [\"-c\", ...this.rawArgs]);\n        proc.hookOut(this, \"watch\");\n        this.output(\"\\u001B[J\");\n        await proc.run();\n    }\n    passInput(input, ident) {\n        if (ident != \"watch\")\n            return;\n        this.output(input);\n    }\n}\nexports.default = watch;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(410);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "c5bec0c7396bd8b26f9049c1b81a92c5511d30d4db1871e22121f407a8584a11"
    },
    "/bin/write": {
      "content": "#!iProcessInstance\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 334:\n/***/ ((__unused_webpack_module, exports) => {\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AppState = void 0;\nclass BaseApp {\n    constructor(proc) {\n        this.helpOutput = false;\n        this.outHooks = [];\n        this.state = AppState.new;\n        this.rawArgs = [];\n        this.inputQueue = [];\n        this.helpText = \"\";\n        this.proc = proc;\n        this.system = proc.system;\n        this.fs = proc.fileSystem;\n        let res = (_i) => { };\n        let rej = (_i) => { };\n        const prom = new Promise((_res, _rej) => {\n            res = _res;\n            rej = _rej;\n        });\n        this.endPromise = {\n            promise: prom,\n            res,\n            rej\n        };\n    }\n    fail(reason) {\n        this.state = AppState.crashed;\n        this.endPromise.rej(this.constructor.name + \": \" + reason + \"\\n\");\n    }\n    kill() {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.killed;\n        this.endPromise.rej(\"\");\n    }\n    hookOut(hook, ident = null) {\n        this.outHooks.push([hook, ident]);\n    }\n    output(out, ident) {\n        if (this.state != AppState.running)\n            return;\n        this.outHooks.forEach(hook => hook[0].input(out, ident || hook[1]));\n    }\n    input(input, ident) {\n        if (this.state != AppState.running)\n            this.queueInput(input, ident);\n        else if (input == \"\\u0018\")\n            this.end(\"\");\n        else if (ident == \"output\")\n            this.output(input, ident);\n        else\n            this.passInput(input, ident);\n    }\n    queueInput(input, ident) {\n        this.inputQueue.push([input, ident]);\n    }\n    passInput(_input, _ident) {\n    }\n    run(args) {\n        if (this.state != AppState.new)\n            return Promise.reject(this.state);\n        this.state = AppState.running;\n        this.rawArgs = [...args];\n        window.setTimeout(() => this.runProcess(args), 0);\n        return this.endPromise.promise;\n    }\n    runProcess(args) {\n        args = this.processArgFlags(args);\n        if (this.helpOutput) {\n            this.outputHelp();\n            return;\n        }\n        this.start(args);\n        while (this.inputQueue.length) {\n            if (this.state != AppState.running)\n                return;\n            const input = this.inputQueue.shift();\n            if (input)\n                this.input(input[0], input[1]);\n        }\n    }\n    endOutput(output) {\n        this.output(output);\n        this.end(output);\n    }\n    end(output) {\n        if (this.state != AppState.running)\n            return;\n        this.state = AppState.ended;\n        this.endPromise.res(output);\n    }\n    processArgFlags(args) {\n        const remaining = [];\n        let used = false;\n        args.forEach((arg, index) => {\n            if (!arg.startsWith(\"-\") || arg.length == 1) {\n                if (!used)\n                    remaining.push(arg);\n                used = false;\n                return;\n            }\n            arg = arg.substr(1);\n            if (arg.startsWith(\"-\")) {\n                used = this.handleFlagIntern(arg.substr(1), args[index + 1] || \"\");\n            }\n            else {\n                arg.split(\"\").forEach(a => {\n                    if (this.handleFlagIntern(a, args[index + 1] || \"\")) {\n                        used = true;\n                    }\n                });\n            }\n        });\n        return remaining;\n    }\n    handleFlagIntern(flag, arg) {\n        switch (flag.toLowerCase()) {\n            case \"help\":\n                this.helpOutput = true;\n                break;\n            default:\n                return this.handleFlag(flag, arg);\n        }\n        return false;\n    }\n    handleFlag(_flag, _arg) {\n        return false;\n    }\n    outputHelp() {\n        try {\n            this.endOutput((this.helpText || this.fs.read(`/etc/man/${this.constructor.name}`))\n                + \"\\n\");\n        }\n        catch (e) {\n            this.fail(e);\n        }\n    }\n}\nexports.default = BaseApp;\nvar AppState;\n(function (AppState) {\n    AppState[\"new\"] = \"new\";\n    AppState[\"running\"] = \"running\";\n    AppState[\"killed\"] = \"killed\";\n    AppState[\"ended\"] = \"ended\";\n    AppState[\"crashed\"] = \"crashed\";\n})(AppState = exports.AppState || (exports.AppState = {}));\n\n\n/***/ }),\n\n/***/ 695:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_1 = __importDefault(__webpack_require__(334));\nclass write extends base_1.default {\n    constructor() {\n        super(...arguments);\n        this.helpText = ` Usage: write [options]... [input] [path]\n write [input] to [file]\n\n\\t-a\\t\\t\\tappend to file\n\\t-e\\t-n\\t\\tdo not add trailing newline`;\n        this.append = false;\n        this.trail = true;\n        this.file = \"\";\n        this.lastHadNewLine = false;\n    }\n    handleFlag(flag, _arg) {\n        switch (flag.toLowerCase()) {\n            case \"a\":\n                this.append = true;\n                break;\n            case \"n\":\n            case \"e\":\n                this.trail = false;\n                break;\n        }\n        return false;\n    }\n    runProcess(args) {\n        super.runProcess(args);\n        this.end(\"\");\n    }\n    end(output) {\n        console.log();\n        if (this.trail && !this.lastHadNewLine) {\n            this.write(\"\\n\", this.file);\n        }\n        super.end(output);\n    }\n    passInput(input, _ident) {\n        if (input instanceof Array) {\n            input = input.map(i => (i instanceof Array) ? i.join(\"\\t\") : i).join(\"\\n\");\n        }\n        this.write(input, this.file, true);\n    }\n    start(args) {\n        if (args.length > 2 || args.length < 1) {\n            this.fail(\"usage : write <flags> <input> [filepath]\");\n        }\n        if (args.length == 1) {\n            this.file = args[0];\n        }\n        else {\n            this.write(args[0], args[1]);\n        }\n    }\n    write(txt, file, log = false) {\n        if (txt.length > 0) {\n            if (this.append) {\n                this.system.fileSystem.append(file, txt);\n            }\n            else {\n                this.system.fileSystem.write(file, txt);\n            }\n            if (log)\n                this.system.debug(\"write\", txt);\n            this.append = true;\n        }\n        const tr = txt.replace(/ +?/g, '');\n        if (txt.length > 0) {\n            this.lastHadNewLine = tr.endsWith(\"\\n\");\n        }\n    }\n}\nexports.default = write;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \treturn __webpack_require__(695);\n/******/ \t\n/******/ })()\n;",
      "perm": "root:root:0755",
      "hash": "cbbc83498d2a60d9d6deeac7feb6f83d53eb9da07633ba962a1f0d8e906b5f7b"
    },
    "/etc/shell/help": {
      "content": "",
      "perm": "root:root:0644",
      "hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
    },
    "/etc/shell/motd": {
      "content": "#!/bin/shell\n\necho \"Welcome to \\033[32mwlf.io\\033[0m TSOS. A pseudo terminal for fun and .... well no profit really...\";\necho \"\";\n\nif \"/usr/bin/help\" is exec;\n    echo \"\\tTry the help command to see what you can do\";\n    echo \"\";\nendif;\n\nif \"~/.last_login\" is file;\n    echo -e \"Last Login: \";\n    cat \"~/.last_login\";\nendif;\n\necho ${date} > \"~/.last_login\";\n",
      "perm": "root:root:0644",
      "hash": "faf4dcfbab15c47a3b995115775a006007085f96e4fe861472914ab1b5fbe407"
    },
    "/etc/shell/profile": {
      "content": "#!/bin/shell\n\nsetenv PS1 \"\\033[0m\\033[32m\\$USER@\\033[32m\\$HOSTNAME\\033[0m:\\033[34m\\$CWD_SHORT\\033[0m\\$\\$ \";\n\nsetenv HOSTNAME ${hostname -e};\n\nsetenv path \"$PATH;/usr/bin\";\n\nif $HOSTNAME == \"127.0.0.1\";\n    setenv HOSTNAME \"dev\";\nendif;\n\nif ~/.profile is exec;\n    ~/.profile;\nendif;\n\nsplit ppp $path \";\";\n\nunique ppp $ppp;\n\njoin ppp $ppp \";\";\n\nsetenv path $ppp;\n",
      "perm": "root:root:0644",
      "hash": "d8a30ba7d2b82b23d9fa504f08a63fd2a19099f8e6bcd5d13964833101ba35b8"
    }
  },
  "sysHash": "ad77e48897b6be0fbdf4f1119f994b50952f3f9a5e3e83d59c4556b215c719b5",
  "hash": "3df2560c1b94ba6facb61e19213f502f0b8737cb8ad942fc053f55e3c022d924"
}